{
  "version": 3,
  "sources": ["../../../node_modules/typescript-parsec/src/Lexer.ts", "../../../node_modules/typescript-parsec/src/Parsers/ParserInterface.ts", "../../../node_modules/typescript-parsec/src/Parsers/TokenParser.ts", "../../../node_modules/typescript-parsec/src/Parsers/MonadicSequencialParser.ts", "../../../node_modules/typescript-parsec/src/Parsers/SequencialParser.ts", "../../../node_modules/typescript-parsec/src/Parsers/AlternativeParser.ts", "../../../node_modules/typescript-parsec/src/Parsers/AlternativeScParser.ts", "../../../node_modules/typescript-parsec/src/Parsers/OptionalParser.ts", "../../../node_modules/typescript-parsec/src/Parsers/ApplyParser.ts", "../../../node_modules/typescript-parsec/src/Parsers/RepeativeParser.ts", "../../../node_modules/typescript-parsec/src/Parsers/AmbiguousParser.ts", "../../../node_modules/typescript-parsec/src/Parsers/ErrorParser.ts", "../../../node_modules/typescript-parsec/src/Parsers/Rule.ts", "../../../node_modules/typescript-parsec/src/ParserModule.ts", "../../../node_modules/typescript-parsec/src/index.ts", "../../../node_modules/uuid/dist/esm-browser/stringify.js", "../../../node_modules/uuid/dist/esm-browser/rng.js", "../../../node_modules/uuid/dist/esm-browser/native.js", "../../../node_modules/uuid/dist/esm-browser/v4.js", "../../../src/glsl-analyzer/parser-combined.ts", "../../../src/utils/result.ts", "../../../src/glsl-analyzer/lexer.ts", "../../../src/glsl-analyzer/glsl-keywords.ts", "../../../src/glsl-analyzer/parser.ts", "../../../src/glsl-analyzer/interleave-comments.ts", "../../../src/glsl-analyzer/useful-combinators.ts", "../../../src/components/iframe-runtime/GLMessageProtocol.ts", "../../../src/glsl-analyzer/get-inputs-outputs.ts", "../../../src/components/iframe-runtime/GLMessageClient.ts", "../../../src/components/iframe-runtime/EvalboxGLWrapper.ts"],
  "sourcesContent": [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n", "let getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n    if (!getRandomValues) {\n        if (typeof crypto === 'undefined' || !crypto.getRandomValues) {\n            throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n        }\n        getRandomValues = crypto.getRandomValues.bind(crypto);\n    }\n    return getRandomValues(rnds8);\n}\n", "const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default { randomUUID };\n", "import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? rng();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nexport default v4;\n", "import {\r\n  expectEOF,\r\n  expectSingleResult,\r\n  Parser,\r\n  Token,\r\n} from \"typescript-parsec\";\r\nimport { err, ok, Result } from \"../utils/result\";\r\nimport { lexer, TokenKind } from \"./lexer\";\r\nimport { translation_unit, TranslationUnit } from \"./parser\";\r\n\r\nexport type ParserResult = {\r\n  translationUnit: TranslationUnit;\r\n};\r\n\r\nexport type ParserError = {\r\n  why: string;\r\n};\r\n\r\nexport function lexGLSL(\r\n  source: string\r\n): Result<Token<TokenKind> | undefined, ParserError> {\r\n  const tokens = lexer.parse(source);\r\n  return ok(tokens);\r\n}\r\n\r\nexport function tryParseGLSLRaw<T>(\r\n  tokens: Token<TokenKind> | undefined,\r\n  parser: Parser<TokenKind, T>\r\n) {\r\n  const result = expectSingleResult(expectEOF(parser.parse(tokens)));\r\n  return result;\r\n}\r\n\r\nexport function parseWith<T>(str: string, parser: Parser<TokenKind, T>) {\r\n  return tryParseGLSLRaw(lexGLSL(str).unsafeExpectSuccess(), parser);\r\n}\r\n\r\nexport function parseGLSLFragmentWithoutPreprocessing<T>(\r\n  source: string,\r\n  parser: Parser<TokenKind, T>\r\n): Result<T, ParserError> {\r\n  const tokens = lexGLSL(source);\r\n\r\n  if (!tokens.data.success) return err(tokens.data.error);\r\n\r\n  try {\r\n    const data = expectSingleResult(expectEOF(parser.parse(tokens.data.data)));\r\n\r\n    return ok(data);\r\n  } catch (error) {\r\n    return err({ why: (error ?? \"\").toString() });\r\n  }\r\n}\r\n\r\nexport function parseGLSLWithoutPreprocessing(\r\n  source: string\r\n): Result<ParserResult, ParserError> {\r\n  const tokens = lexGLSL(source);\r\n\r\n  if (!tokens.data.success) return err(tokens.data.error);\r\n\r\n  try {\r\n    const translationUnit = expectSingleResult(\r\n      expectEOF(translation_unit.parse(tokens.data.data))\r\n    );\r\n\r\n    return ok({\r\n      translationUnit,\r\n    });\r\n  } catch (error) {\r\n    return err({ why: (error ?? \"\").toString() });\r\n  }\r\n}\r\n", "export type ResultSuccess<T> = {\r\n  readonly success: true;\r\n  readonly data: T;\r\n};\r\nexport type ResultError<E> = {\r\n  readonly success: false;\r\n  readonly error: E;\r\n};\r\n\r\nexport class Result<T, E> {\r\n  readonly data: ResultSuccess<T> | ResultError<E>;\r\n  constructor(data: ResultSuccess<T> | ResultError<E>) {\r\n    this.data = data;\r\n  }\r\n\r\n  unsafeExpectSuccess() {\r\n    if (this.data.success) return this.data.data;\r\n\r\n    throw new Error(\"Expected a non-error response from a Result!\");\r\n  }\r\n\r\n  mapS<T2>(f: (t: T) => T2): Result<T2, E> {\r\n    if (this.data.success)\r\n      return new Result<T2, E>({\r\n        success: true,\r\n        data: f(this.data.data),\r\n      });\r\n\r\n    // @ts-expect-error T and T2 only matter if this is a ResultSuccess\r\n    return this as Result<T2, E>;\r\n  }\r\n\r\n  mapE<E2>(f: (e: E) => E2): Result<T, E2> {\r\n    if (!this.data.success)\r\n      return new Result<T, E2>({\r\n        success: false,\r\n        error: f(this.data.error),\r\n      });\r\n\r\n    // @ts-expect-error T and T2 only matter if this is a ResultSuccess\r\n    return this as Result<T2, E>;\r\n  }\r\n}\r\n\r\nexport function ok<T, E>(data: T) {\r\n  return new Result<T, E>({ success: true, data });\r\n}\r\n\r\nexport function err<T, E>(error: E) {\r\n  return new Result<T, E>({ success: false, error });\r\n}\r\n\r\nexport function splitSuccessesAndErrors<T, E>(\r\n  results: Result<T, E>[]\r\n): [T[], E[]] {\r\n  const successes: T[] = [];\r\n  const errors: E[] = [];\r\n\r\n  for (const r of results) {\r\n    if (r.data.success) {\r\n      successes.push(r.data.data);\r\n    } else {\r\n      errors.push(r.data.error);\r\n    }\r\n  }\r\n\r\n  return [successes, errors];\r\n}\r\n", "import { buildLexer, tok } from \"typescript-parsec\";\r\nimport { GLSL_KEYWORDS, GLSL_SYMBOLS } from \"./glsl-keywords\";\r\n\r\nexport enum TokenKind {\r\n  Symbol,\r\n  Keyword,\r\n  Whitespace,\r\n  Comment,\r\n  Identifier,\r\n  IntegerDecimal,\r\n  IntegerOctal,\r\n  IntegerHex,\r\n  Float,\r\n  ImportString,\r\n}\r\n\r\nexport const lexer = buildLexer([\r\n  // all keywords\r\n  [\r\n    true,\r\n    new RegExp(GLSL_KEYWORDS.map((k) => `^${k}`).join(\"|\"), \"g\"),\r\n    TokenKind.Keyword,\r\n  ],\r\n  // all symbols\r\n  [\r\n    true,\r\n    new RegExp(\r\n      `^(${GLSL_SYMBOLS.map((s) =>\r\n        s\r\n          .split(\"\")\r\n          .map((c) => `\\\\${c}`)\r\n          .join(\"\")\r\n      ).join(\"|\")})`,\r\n      \"g\"\r\n    ),\r\n    TokenKind.Symbol,\r\n  ],\r\n  // whitespace\r\n  [false, /^\\s+/g, TokenKind.Whitespace],\r\n  // comments (comments will be included in AST)\r\n  [true, /^(\\/\\/[^\\n]*\\n)|^(\\/\\*[\\s\\S]*?\\*\\/)/g, TokenKind.Comment],\r\n  // identifiers\r\n  [true, /^[a-zA-Z_][a-zA-Z0-9_]*/g, TokenKind.Identifier],\r\n  // ints\r\n  [true, /^[1-9][0-9]*[uU]?/g, TokenKind.IntegerDecimal],\r\n  [true, /^0[0-7]*[uU]?/g, TokenKind.IntegerOctal],\r\n  [true, /^0[xX][0-9a-fA-F]+[uU]?/g, TokenKind.IntegerHex],\r\n  // floats\r\n  [\r\n    true,\r\n    /^([0-9]+\\.[0-9]*|\\.[0-9]+)([eE][\\+\\-]?[0-9]+)?[fF]?/g,\r\n    TokenKind.Float,\r\n  ],\r\n  [true, /^[0-9]+[eE][\\+\\-][0-9]+[fF]?/g, TokenKind.Float],\r\n  // import strings\r\n  [true, /^\"[^\"]*\"/g, TokenKind.ImportString],\r\n]);\r\n", "export const GLSL_KEYWORDS = [\r\n  // copied from grammar\r\n  \"const\",\r\n  \"bool\",\r\n  \"float\",\r\n  \"int\",\r\n  \"uint\",\r\n  \"break\",\r\n  \"continue\",\r\n  \"do\",\r\n  \"else\",\r\n  \"for\",\r\n  \"if\",\r\n  \"discard\",\r\n  \"return\",\r\n  \"switch\",\r\n  \"case\",\r\n  \"default\",\r\n  \"bvec2\",\r\n  \"bvec3\",\r\n  \"bvec4\",\r\n  \"ivec2\",\r\n  \"ivec3\",\r\n  \"ivec4\",\r\n  \"uvec2\",\r\n  \"uvec3\",\r\n  \"uvec4\",\r\n  \"vec2\",\r\n  \"vec3\",\r\n  \"vec4\",\r\n  \"mat2\",\r\n  \"mat3\",\r\n  \"mat4\",\r\n  \"centroid\",\r\n  \"in\",\r\n  \"out\",\r\n  \"inout\",\r\n  \"uniform\",\r\n  \"flat\",\r\n  \"smooth\",\r\n  \"layout\",\r\n  \"mat2x2\",\r\n  \"mat2x3\",\r\n  \"mat2x4\",\r\n  \"mat3x2\",\r\n  \"mat3x3\",\r\n  \"mat3x4\",\r\n  \"mat4x2\",\r\n  \"mat4x3\",\r\n  \"mat4x4\",\r\n  \"sampler2d\",\r\n  \"sampler3d\",\r\n  \"samplercube\",\r\n  \"sampler2dshadow\",\r\n  \"samplercubeshadow\",\r\n  \"sampler2darray\",\r\n  \"sampler2darrayshadow\",\r\n  \"isampler2d\",\r\n  \"isampler3d\",\r\n  \"isamplercube\",\r\n  \"isampler2darray\",\r\n  \"usampler2d\",\r\n  \"usampler3d\",\r\n  \"usamplercube\",\r\n  \"usampler2darray\",\r\n  \"struct\",\r\n  \"void\",\r\n  \"while\",\r\n  \"invariant\",\r\n  \"highp\",\r\n  \"mediump\",\r\n  \"lowp\",\r\n  \"true\",\r\n  \"false\",\r\n  // taken from elsewhere\r\n  \"shared\",\r\n  \"packed\",\r\n  \"std140\",\r\n  \"row_major\",\r\n  \"column_major\",\r\n];\r\n\r\nexport const GLSL_SYMBOLS = [\r\n  \"*=\",\r\n  \"/=\",\r\n  \"%=\",\r\n  \"+=\",\r\n  \"-=\",\r\n  \"<<=\",\r\n  \">>=\",\r\n  \"&=\",\r\n  \"^=\",\r\n  \"|=\",\r\n  \"++\",\r\n  \"--\",\r\n  \"==\",\r\n  \"!=\",\r\n  \">=\",\r\n  \"<=\",\r\n  \"&&\",\r\n  \"||\",\r\n  \"^^\",\r\n  \"<<\",\r\n  \">>\",\r\n  \"(\",\r\n  \")\",\r\n  \"[\",\r\n  \"]\",\r\n  \"{\",\r\n  \"}\",\r\n  \".\",\r\n  \",\",\r\n  \":\",\r\n  \"=\",\r\n  \";\",\r\n  \"!\",\r\n  \"-\",\r\n  \"~\",\r\n  \"+\",\r\n  \"*\",\r\n  \"/\",\r\n  \"%\",\r\n  \"<\",\r\n  \">\",\r\n  \"|\",\r\n  \"^\",\r\n  \"&\",\r\n  \"?\",\r\n];\r\n", "import {\r\n  alt_sc,\r\n  apply,\r\n  kleft,\r\n  kmid,\r\n  kright,\r\n  lrec_sc,\r\n  nil,\r\n  opt_sc,\r\n  Parser,\r\n  rep_sc,\r\n  rule,\r\n  seq,\r\n  str,\r\n  tok,\r\n} from \"typescript-parsec\";\r\nimport { TokenKind } from \"./lexer\";\r\nimport {\r\n  add_comments,\r\n  add_comments_and_transform,\r\n  append_comments,\r\n  binop,\r\n  binop_generic,\r\n  comment_parser,\r\n  commentify,\r\n  commentify_no_comments_before,\r\n  custom_node,\r\n  nodeify,\r\n  nodeify_commented,\r\n  stretch_node,\r\n  with_comment_before,\r\n} from \"./interleave-comments\";\r\nimport { lstr } from \"./useful-combinators\";\r\n\r\n// check the grammar in the GL ES specification\r\n// https://registry.khronos.org/OpenGL/specs/es/3.0/GLSL_ES_Specification_3.00.pdf\r\n\r\ntype ErrorExpr = {\r\n  type: \"error\";\r\n  why: string;\r\n  _isExpr: true;\r\n};\r\n\r\ntype IntExpr = {\r\n  type: \"int\";\r\n  int: number;\r\n  asString: string; // need this so autoformatter doesn't change the number\r\n  _isExpr: true;\r\n};\r\n\r\ntype FloatExpr = {\r\n  type: \"float\";\r\n  float: number;\r\n  asString: string; // need this so autoformatter doesn't change the number\r\n  _isExpr: true;\r\n};\r\n\r\ntype BoolExpr = {\r\n  type: \"bool\";\r\n  bool: boolean;\r\n  _isExpr: true;\r\n};\r\n\r\ntype VariableExpr = {\r\n  type: \"ident\";\r\n  ident: string;\r\n  _isExpr: true;\r\n};\r\n\r\ntype ConditionalExpr = {\r\n  type: \"conditional\";\r\n  condition: ASTNode<Expr>;\r\n  ifTrue: ASTNode<Expr>;\r\n  ifFalse: ASTNode<Expr>;\r\n  _isExpr: true;\r\n};\r\n\r\nexport type Comment = {\r\n  comment: string;\r\n};\r\n\r\nexport type BinaryOpExpr = {\r\n  type: \"binary-op\";\r\n  left: ASTNode<Expr>;\r\n  right: ASTNode<Expr>;\r\n  op: // arithmetic\r\n  | \"+\"\r\n    | \"-\"\r\n    | \"*\"\r\n    | \"/\"\r\n    | \"%\"\r\n    // comparison\r\n    | \"==\"\r\n    | \"!=\"\r\n    | \">\"\r\n    | \"<\"\r\n    | \">=\"\r\n    | \"<=\"\r\n    // logical\r\n    | \"&&\"\r\n    | \"||\"\r\n    | \"^^\"\r\n    // array access\r\n    | \"[]\"\r\n    // bitwise\r\n    | \"&\"\r\n    | \"^\"\r\n    | \"|\"\r\n    | \">>\"\r\n    | \"<<\"\r\n    // other\r\n    | \",\";\r\n  _isExpr: true;\r\n};\r\n\r\ntype AssignmentExpr = {\r\n  type: \"assignment\";\r\n  left: ASTNode<Expr>;\r\n  right: ASTNode<Expr>;\r\n  op: AssignmentOperator;\r\n  _isExpr: true;\r\n};\r\n\r\ntype UnaryOpExpr = {\r\n  type: \"unary-op\";\r\n  left: ASTNode<Expr>;\r\n  op: \"++\" | \"--\" | \"!\" | \"~\";\r\n  isAfter: boolean;\r\n  _isExpr: true;\r\n};\r\n\r\ntype FieldAccessExpr = {\r\n  type: \"field-access\";\r\n  left: ASTNode<Expr>;\r\n  right: ASTNode<Expr>;\r\n  _isExpr: true;\r\n};\r\n\r\ntype FunctionCallExpr = {\r\n  type: \"function-call\";\r\n  identifier: FunctionIdentifier;\r\n  args: ASTNode<Expr>[];\r\n  isVoid: boolean;\r\n  _isExpr: true;\r\n};\r\n\r\ntype FunctionCallFieldAccessExpr = {\r\n  type: \"function-call-field-access\";\r\n  left: ASTNode<Expr>;\r\n  right: ASTNode<Expr>;\r\n  _isExpr: true;\r\n};\r\n\r\nexport type Expr =\r\n  | ErrorExpr\r\n  | IntExpr\r\n  | FloatExpr\r\n  | BoolExpr\r\n  | VariableExpr\r\n  | BinaryOpExpr\r\n  | UnaryOpExpr\r\n  | FieldAccessExpr\r\n  | FunctionCallExpr\r\n  | FunctionCallFieldAccessExpr\r\n  | ConditionalExpr\r\n  | AssignmentExpr;\r\n\r\nexport type ExprStmt = {\r\n  type: \"expr\";\r\n  expr?: ASTNode<Expr>;\r\n  _isStmt: true;\r\n};\r\n\r\nexport type SwitchStmt = {\r\n  type: \"switch\";\r\n  expr: ASTNode<Expr>;\r\n  stmts: ASTNode<Stmt>[];\r\n  _isStmt: true;\r\n};\r\n\r\nexport type CaseLabelStmt = {\r\n  type: \"case\";\r\n  expr: ASTNode<Expr>;\r\n  _isStmt: true;\r\n};\r\n\r\nexport type DefaultCaseLabelStmt = {\r\n  type: \"default-case\";\r\n  _isStmt: true;\r\n};\r\n\r\nexport type JumpStmt = {\r\n  type: \"continue\" | \"break\" | \"discard\";\r\n  _isStmt: true;\r\n};\r\n\r\nexport type ReturnStmt = {\r\n  type: \"return\";\r\n  expr?: ASTNode<Expr>;\r\n  _isStmt: true;\r\n};\r\n\r\nexport type DeclarationStmt = {\r\n  type: \"declaration\";\r\n  decl: Commented<Declaration>;\r\n  _isStmt: true;\r\n};\r\n\r\nexport type CompoundStmt = {\r\n  statements: ASTNode<Stmt>[];\r\n  type: \"compound\";\r\n  _isStmt: true;\r\n};\r\n\r\nexport type SelectionStmt = {\r\n  cond: ASTNode<Expr>;\r\n  rest: Commented<SelectionRestStmt>;\r\n  type: \"selection\";\r\n  _isStmt: true;\r\n};\r\n\r\nexport type SelectionRestStmt = {\r\n  if: ASTNode<Stmt>;\r\n  else?: ASTNode<Stmt>;\r\n  _isStmt: true;\r\n};\r\n\r\nexport type IterationStmt =\r\n  | {\r\n      type: \"while\";\r\n      cond: Commented<Condition>;\r\n      body: ASTNode<Stmt>;\r\n      _isStmt: true;\r\n    }\r\n  | {\r\n      type: \"do-while\";\r\n      cond: ASTNode<Expr>;\r\n      body: ASTNode<Stmt>;\r\n      _isStmt: true;\r\n    }\r\n  | {\r\n      type: \"for\";\r\n      init: ASTNode<Stmt>;\r\n      rest: Commented<ForRestStatement>;\r\n      body: ASTNode<Stmt>;\r\n      _isStmt: true;\r\n    };\r\n\r\nexport type Stmt =\r\n  | ExprStmt\r\n  | SwitchStmt\r\n  | CaseLabelStmt\r\n  | DefaultCaseLabelStmt\r\n  | JumpStmt\r\n  | ReturnStmt\r\n  | DeclarationStmt\r\n  | CompoundStmt\r\n  | SelectionStmt\r\n  | IterationStmt;\r\n\r\nexport type ExternalDeclarationFunction = {\r\n  type: \"function\";\r\n  prototype: Commented<FunctionHeader>;\r\n  body: ASTNode<CompoundStmt>;\r\n  _isExtDecl: true;\r\n};\r\n\r\nexport type ExternalDeclarationDeclaration = {\r\n  type: \"declaration\";\r\n  decl: Commented<Declaration>;\r\n  _isExtDecl: true;\r\n};\r\nexport type SingleItemImport = {\r\n  name: string;\r\n  alias?: string;\r\n};\r\n\r\nexport type Imports =\r\n  | {\r\n      type: \"all\";\r\n      prefix: string;\r\n    }\r\n  | {\r\n      type: \"some\";\r\n      imports: ASTNode<SingleItemImport>[];\r\n    };\r\n\r\nexport type ExternalDeclarationImport = {\r\n  type: \"import\";\r\n  from: string;\r\n  imports: Commented<Imports>;\r\n};\r\n\r\nexport type ExternalDeclaration =\r\n  | ExternalDeclarationFunction\r\n  | ExternalDeclarationDeclaration\r\n  | ExternalDeclarationImport;\r\n\r\nexport type ASTNode<T> = {\r\n  data: T;\r\n  // outer array to account for different spots comments can appear in\r\n  // inner array to list comments\r\n  comments: Comment[][];\r\n  range: { start: number; end: number };\r\n  _isNode: true;\r\n};\r\n\r\nexport function dummyNode<T>(data: T): ASTNode<T> {\r\n  return {\r\n    data,\r\n    comments: [],\r\n    range: { start: 0, end: 0 },\r\n    _isNode: true,\r\n  };\r\n}\r\n\r\n// wrapper for comments\r\nexport type Commented<T> = {\r\n  data: T;\r\n  comments: Comment[][];\r\n};\r\n\r\nexport type Declaration =\r\n  | {\r\n      type: \"function-prototype\";\r\n      prototype: Commented<FunctionHeader>;\r\n      _isDecl: true;\r\n    }\r\n  | {\r\n      type: \"declarator-list\";\r\n      declaratorList: Commented<InitDeclaratorList>;\r\n      _isDecl: true;\r\n    }\r\n  | {\r\n      type: \"type-specifier\";\r\n      precision: Commented<Precision>;\r\n      specifier: Commented<TypeNoPrec>;\r\n      _isDecl: true;\r\n    }\r\n  | {\r\n      type: \"struct\";\r\n      typeQualifier: Commented<TypeQualifier>;\r\n      name: Commented<string>;\r\n      name2?: Commented<string>;\r\n      declarationList: Commented<StructDeclarationList>;\r\n      constantExpr?: ASTNode<Expr>;\r\n      _isDecl: true;\r\n    }\r\n  | {\r\n      type: \"type-qualifier\";\r\n      typeQualifier: Commented<TypeQualifier>;\r\n      _isDecl: true;\r\n    };\r\n\r\nexport type FunctionIdentifier =\r\n  | {\r\n      type: \"function-identifier\";\r\n      identifier: string;\r\n    }\r\n  | TypeSpecifier;\r\n\r\nexport type TypeSpecifier = {\r\n  type: \"type-specifier\";\r\n  precision?: Commented<Precision>;\r\n  specifier: Commented<TypeNoPrec>;\r\n};\r\n\r\nexport type TypeNoPrec = {\r\n  typeName: Commented<TypeSpecifierNonarray>;\r\n  // for if this is an array\r\n  arrayType:\r\n    | {\r\n        type: \"static\";\r\n        size: ASTNode<Expr>;\r\n      }\r\n    | {\r\n        type: \"dynamic\";\r\n      }\r\n    | { type: \"none\" };\r\n};\r\n\r\nexport type TypeSpecifierNonarray =\r\n  | {\r\n      type: \"builtin\";\r\n      name: Commented<string>;\r\n    }\r\n  | {\r\n      type: \"struct\";\r\n      struct: Commented<StructSpecifier>;\r\n    }\r\n  | {\r\n      type: \"custom\";\r\n      name: Commented<string>;\r\n    };\r\n\r\nexport type TypeQualifier =\r\n  | {\r\n      type: \"sq\";\r\n      storageQualifier: Commented<StorageQualifier>;\r\n    }\r\n  | {\r\n      type: \"lq-sq\";\r\n      layoutQualifier: Commented<LayoutQualifier>;\r\n      storageQualifier?: Commented<StorageQualifier>;\r\n    }\r\n  | {\r\n      type: \"intq-sq\";\r\n      interpolationQualifier: Commented<InterpolationQualifier>;\r\n      storageQualifier?: Commented<StorageQualifier>;\r\n    }\r\n  | {\r\n      type: \"invq-intq-sq\";\r\n      invariantQualifier: Commented<InvariantQualifier>;\r\n      interpolationQualifier?: Commented<InterpolationQualifier>;\r\n      storageQualifier: Commented<StorageQualifier>;\r\n    };\r\n\r\nexport type LayoutQualifier = Commented<LayoutQualifierId>[];\r\n\r\nexport type InvariantQualifier = \"invariant\";\r\n\r\nexport type InterpolationQualifier = \"smooth\" | \"flat\";\r\n\r\nexport type StorageQualifier =\r\n  | \"const\"\r\n  | \"in\"\r\n  | \"out\"\r\n  | \"centroid in\"\r\n  | \"centroid out\"\r\n  | \"uniform\";\r\n\r\nexport type Precision = \"lowp\" | \"mediump\" | \"highp\";\r\n\r\nexport type AssignmentOperator =\r\n  | \"=\"\r\n  | \"*=\"\r\n  | \"/=\"\r\n  | \"%=\"\r\n  | \"+=\"\r\n  | \"-=\"\r\n  | \"<<=\"\r\n  | \">>=\"\r\n  | \"&=\"\r\n  | \"^=\"\r\n  | \"|=\";\r\n\r\nexport type LayoutQualifierId = {\r\n  identifier: string;\r\n  value?: number;\r\n};\r\n\r\nexport type InitDeclaratorList = {\r\n  init: Commented<SingleDeclarationStart>;\r\n  declarations: Commented<Commented<SingleDeclaration>[]>;\r\n};\r\n\r\nexport type SingleDeclarationVariant =\r\n  | {\r\n      type: \"sized-array\";\r\n      size: ASTNode<Expr>;\r\n    }\r\n  | {\r\n      type: \"initialized-array\";\r\n      size?: ASTNode<Expr>;\r\n      initializer: ASTNode<Expr>;\r\n    }\r\n  | {\r\n      type: \"initialized\";\r\n      initializer: ASTNode<Expr>;\r\n    };\r\n\r\nexport type SingleDeclaration = {\r\n  name: Commented<string>;\r\n  variant?: Commented<SingleDeclarationVariant>;\r\n};\r\n\r\nexport type SingleDeclarationStart =\r\n  | {\r\n      type: \"type\";\r\n      declType: Commented<FullySpecifiedType>;\r\n    }\r\n  | {\r\n      type: \"invariant\";\r\n    };\r\n\r\nexport type FullySpecifiedType = {\r\n  specifier: Commented<TypeSpecifier>;\r\n  qualifier?: Commented<TypeQualifier>;\r\n};\r\n\r\nexport type ParameterTypeQualifier = \"const\";\r\n\r\nexport type ParameterQualifier = \"in\" | \"out\" | \"inout\";\r\n\r\nexport type ParameterTypeSpecifier = TypeSpecifier;\r\n\r\nexport type ParameterDeclarator = {\r\n  typeSpecifier: Commented<TypeSpecifier>;\r\n  identifier: Commented<string>;\r\n  arraySize?: ASTNode<Expr>;\r\n};\r\n\r\nexport type FunctionHeader = {\r\n  fullySpecifiedType: Commented<FullySpecifiedType>;\r\n  name: Commented<string>;\r\n  parameters?: Commented<Commented<ParameterDeclaration>[]>;\r\n};\r\n\r\nexport type ParameterDeclaration = {\r\n  parameterTypeQualifier?: Commented<ParameterTypeQualifier>;\r\n  parameterQualifier?: Commented<ParameterQualifier>;\r\n  declaratorOrSpecifier:\r\n    | {\r\n        type: \"declarator\";\r\n        declarator: Commented<ParameterDeclarator>;\r\n      }\r\n    | {\r\n        type: \"specifier\";\r\n        specifier: Commented<ParameterTypeSpecifier>;\r\n      };\r\n};\r\n\r\nexport type StructSpecifier = {\r\n  members: Commented<StructDeclarationList>;\r\n  name?: Commented<string>;\r\n  _isStruct: true;\r\n};\r\n\r\nexport type StructDeclarationList = Commented<StructDeclaration>[];\r\n\r\nexport type StructDeclaration = {\r\n  typeQualifier?: Commented<TypeQualifier>;\r\n  typeSpecifier: Commented<TypeSpecifier>;\r\n  declaratorList: Commented<StructDeclaratorList>;\r\n};\r\n\r\nexport type StructDeclaratorList = Commented<StructDeclarator>[];\r\n\r\nexport type StructDeclarator = {\r\n  name: string;\r\n  isArray?: {\r\n    expr?: ASTNode<Expr>;\r\n  };\r\n};\r\n\r\nexport type ForRestStatement = {\r\n  condition?: Commented<Condition>;\r\n  expr?: ASTNode<Expr>;\r\n};\r\n\r\nexport type Condition =\r\n  | {\r\n      type: \"expr\";\r\n      expr: ASTNode<Expr>;\r\n    }\r\n  | {\r\n      type: \"type-equal-init\";\r\n      fullySpecifiedType: Commented<FullySpecifiedType>;\r\n      name: Commented<string>;\r\n      initializer: ASTNode<Expr>;\r\n    };\r\n\r\nfunction glslParseInt(str: string): number {\r\n  throw new Error(\"TODO\");\r\n}\r\n\r\nexport type TranslationUnit = Commented<ASTNode<ExternalDeclaration>[]>;\r\n\r\nconst variable_identifier = rule<TokenKind, ASTNode<Expr>>();\r\nexport const primary_expression = rule<TokenKind, ASTNode<Expr>>();\r\nexport const postfix_expression = rule<TokenKind, ASTNode<Expr>>();\r\nexport const integer_expression = rule<TokenKind, ASTNode<Expr>>();\r\nexport const function_call = rule<TokenKind, ASTNode<Expr>>();\r\nconst function_call_or_method = rule<TokenKind, ASTNode<Expr>>();\r\nexport const function_call_generic = rule<\r\n  TokenKind,\r\n  ASTNode<FunctionCallExpr>\r\n>();\r\nexport const function_call_header_no_parameters = rule<\r\n  TokenKind,\r\n  Commented<FunctionCallExpr>\r\n>();\r\nexport const function_call_header_with_parameters = rule<\r\n  TokenKind,\r\n  Commented<FunctionCallExpr>\r\n>();\r\nexport const function_call_header = rule<\r\n  TokenKind,\r\n  Commented<FunctionIdentifier>\r\n>();\r\nconst function_identifier = rule<TokenKind, Commented<FunctionIdentifier>>();\r\nexport const unary_expression = rule<TokenKind, ASTNode<Expr>>();\r\nconst unary_operator = rule<TokenKind, ASTNode<Expr>>();\r\nexport const multiplicative_expression = rule<TokenKind, ASTNode<Expr>>();\r\nconst additive_expression = rule<TokenKind, ASTNode<Expr>>();\r\nconst shift_expression = rule<TokenKind, ASTNode<Expr>>();\r\nconst relational_expression = rule<TokenKind, ASTNode<Expr>>();\r\nconst equality_expression = rule<TokenKind, ASTNode<Expr>>();\r\nexport const and_expression = rule<TokenKind, ASTNode<Expr>>();\r\nconst exclusive_or_expression = rule<TokenKind, ASTNode<Expr>>();\r\nconst inclusive_or_expression = rule<TokenKind, ASTNode<Expr>>();\r\nconst logical_and_expression = rule<TokenKind, ASTNode<Expr>>();\r\nconst logical_xor_expression = rule<TokenKind, ASTNode<Expr>>();\r\nexport const logical_or_expression = rule<TokenKind, ASTNode<Expr>>();\r\nconst conditional_expression = rule<TokenKind, ASTNode<Expr>>();\r\nexport const assignment_expression = rule<TokenKind, ASTNode<Expr>>();\r\nconst assignment_operator = rule<TokenKind, AssignmentOperator>();\r\nexport const expression = rule<TokenKind, ASTNode<Expr>>();\r\nconst constant_expression = rule<TokenKind, ASTNode<Expr>>();\r\nexport const declaration = rule<TokenKind, Commented<Declaration>>();\r\nconst function_prototype = rule<TokenKind, Commented<FunctionHeader>>();\r\nconst function_declarator = rule<TokenKind, Commented<FunctionHeader>>();\r\nconst function_header_with_parameters = rule<\r\n  TokenKind,\r\n  Commented<FunctionHeader>\r\n>();\r\nconst function_header = rule<TokenKind, Commented<FunctionHeader>>();\r\nexport const parameter_declarator = rule<\r\n  TokenKind,\r\n  Commented<ParameterDeclarator>\r\n>();\r\nconst parameter_declaration = rule<\r\n  TokenKind,\r\n  Commented<ParameterDeclaration>\r\n>();\r\nconst parameter_qualifier = rule<\r\n  TokenKind,\r\n  ASTNode<ParameterQualifier> | undefined\r\n>();\r\nconst parameter_type_specifier = rule<TokenKind, Commented<TypeSpecifier>>();\r\nexport const init_declarator_list = rule<\r\n  TokenKind,\r\n  Commented<InitDeclaratorList>\r\n>();\r\nconst single_declaration = rule<TokenKind, ASTNode<Expr>>();\r\nexport const fully_specified_type = rule<\r\n  TokenKind,\r\n  Commented<FullySpecifiedType>\r\n>();\r\nconst invariant_qualifier = rule<TokenKind, Commented<InvariantQualifier>>();\r\nconst interpolation_qualifier = rule<\r\n  TokenKind,\r\n  Commented<InterpolationQualifier>\r\n>();\r\nexport const layout_qualifier = rule<TokenKind, Commented<LayoutQualifier>>();\r\nconst layout_qualifier_id_list = rule<TokenKind, Commented<LayoutQualifier>>();\r\nexport const layout_qualifier_id = rule<\r\n  TokenKind,\r\n  Commented<LayoutQualifierId>\r\n>();\r\nconst parameter_type_qualifier = rule<\r\n  TokenKind,\r\n  Commented<ParameterTypeQualifier>\r\n>();\r\nconst type_qualifier = rule<TokenKind, Commented<TypeQualifier>>();\r\nconst storage_qualifier = rule<TokenKind, Commented<StorageQualifier>>();\r\nconst type_specifier = rule<TokenKind, Commented<TypeSpecifier>>();\r\nconst type_specifier_no_prec = rule<TokenKind, Commented<TypeNoPrec>>();\r\nconst type_specifier_nonarray = rule<\r\n  TokenKind,\r\n  Commented<TypeSpecifierNonarray>\r\n>();\r\nconst precision_qualifier = rule<TokenKind, Commented<Precision>>();\r\nconst struct_specifier = rule<TokenKind, Commented<StructSpecifier>>();\r\nconst struct_declaration_list = rule<\r\n  TokenKind,\r\n  Commented<StructDeclarationList>\r\n>();\r\nconst struct_declaration = rule<TokenKind, Commented<StructDeclaration>>();\r\nconst struct_declarator_list = rule<\r\n  TokenKind,\r\n  Commented<StructDeclaratorList>\r\n>();\r\nconst struct_declarator = rule<TokenKind, Commented<StructDeclarator>>();\r\nconst initializer = rule<TokenKind, ASTNode<Expr>>();\r\nconst declaration_statement = rule<TokenKind, ASTNode<Stmt>>();\r\nexport const statement = rule<TokenKind, ASTNode<Stmt>>();\r\nconst statement_no_new_scope = rule<TokenKind, ASTNode<Stmt>>();\r\nconst statement_with_scope = rule<TokenKind, ASTNode<Stmt>>();\r\nconst simple_statement = rule<TokenKind, ASTNode<Stmt>>();\r\nconst compound_statement_with_scope = rule<TokenKind, ASTNode<CompoundStmt>>();\r\nconst compound_statement_no_new_scope = rule<\r\n  TokenKind,\r\n  ASTNode<CompoundStmt>\r\n>();\r\nconst statement_list = rule<TokenKind, ASTNode<Stmt>[]>();\r\nconst expression_statement = rule<TokenKind, ASTNode<Stmt>>();\r\nconst selection_statement = rule<TokenKind, ASTNode<Stmt>>();\r\nconst selection_rest_statement = rule<\r\n  TokenKind,\r\n  Commented<SelectionRestStmt>\r\n>();\r\nconst condition = rule<TokenKind, Commented<Condition>>();\r\nconst switch_statement = rule<TokenKind, ASTNode<Stmt>>();\r\nconst switch_statement_list = rule<TokenKind, ASTNode<Stmt>[] | undefined>();\r\nconst case_label = rule<TokenKind, ASTNode<Stmt>>();\r\nconst iteration_statement = rule<TokenKind, ASTNode<Stmt>>();\r\nconst for_init_statement = rule<TokenKind, ASTNode<Stmt>>();\r\nconst conditionopt = rule<TokenKind, Commented<Condition> | undefined>();\r\nconst for_rest_statement = rule<TokenKind, Commented<ForRestStatement>>();\r\nconst jump_statement = rule<TokenKind, ASTNode<Stmt>>();\r\nexport const translation_unit = rule<TokenKind, TranslationUnit>();\r\nexport const external_declaration = rule<\r\n  TokenKind,\r\n  ASTNode<ExternalDeclaration>\r\n>();\r\nconst function_definition = rule<TokenKind, ASTNode<ExternalDeclaration>>();\r\n\r\nconst placeholder = nodeify(\r\n  apply(nil<TokenKind>(), () => ({\r\n    type: \"error\" as const,\r\n    why: \"Placeholder encountered during parsing!\",\r\n  }))\r\n);\r\n\r\nvariable_identifier.setPattern(\r\n  nodeify(\r\n    apply(tok(TokenKind.Identifier), (s) => ({\r\n      type: \"ident\",\r\n      ident: s.text,\r\n      _isExpr: true,\r\n    }))\r\n  )\r\n);\r\n\r\nprimary_expression.setPattern(\r\n  alt_sc(\r\n    // identifier\r\n    variable_identifier,\r\n    nodeify(\r\n      alt_sc(\r\n        // integer literals\r\n        apply(\r\n          alt_sc(\r\n            tok(TokenKind.IntegerDecimal),\r\n            tok(TokenKind.IntegerOctal),\r\n            tok(TokenKind.IntegerHex)\r\n          ),\r\n          (tok) => {\r\n            const num =\r\n              tok.text[0] == \"0\" ? parseInt(tok.text, 8) : parseInt(tok.text);\r\n            return {\r\n              type: \"int\",\r\n              int: num,\r\n              asString: tok.text,\r\n              _isExpr: true,\r\n            };\r\n          }\r\n        ),\r\n        // float literal\r\n        apply(tok(TokenKind.Float), (float) => ({\r\n          type: \"float\",\r\n          float: parseFloat(float.text),\r\n          asString: float.text,\r\n          _isExpr: true,\r\n        })),\r\n        // boolean literal\r\n        apply(alt_sc(str(\"true\"), str(\"false\")), (bool) => ({\r\n          type: \"bool\",\r\n          bool: bool.text == \"true\",\r\n          _isExpr: true,\r\n        }))\r\n      )\r\n    ),\r\n    // parenthesized expression\r\n    add_comments(\r\n      seq(comment_parser, str(\"(\"), expression, comment_parser, str(\")\")),\r\n      (t) => t[2],\r\n      (c, oc) => [c[0], ...oc, c[3]]\r\n    )\r\n  )\r\n);\r\n\r\nconst field_access: Parser<TokenKind, ASTNode<Expr>> =\r\n  // a.b\r\n  binop_generic(\r\n    alt_sc(function_call_generic, primary_expression),\r\n    seq(comment_parser, str(\".\"), comment_parser, postfix_expression),\r\n    (left: ASTNode<Expr>, right) => [\r\n      {\r\n        type: \"field-access\",\r\n        left,\r\n        right: right[3],\r\n        _isExpr: true,\r\n      },\r\n      [right[0], right[2]],\r\n    ]\r\n  );\r\n\r\npostfix_expression.setPattern(\r\n  alt_sc(\r\n    // a[b]\r\n    binop_generic(\r\n      primary_expression,\r\n      seq(\r\n        comment_parser,\r\n        str(\"[\"),\r\n        integer_expression,\r\n        comment_parser,\r\n        str(\"]\")\r\n      ),\r\n      (left, right) => [\r\n        {\r\n          left,\r\n          right: right[2],\r\n          type: \"binary-op\",\r\n          op: \"[]\",\r\n          _isExpr: true,\r\n        },\r\n        [right[0], right[3]],\r\n      ]\r\n    ),\r\n    // a++, a--\r\n    binop_generic(\r\n      primary_expression,\r\n      seq(comment_parser, alt_sc(str(\"++\"), str(\"--\"))),\r\n      (left, right) => [\r\n        {\r\n          type: \"unary-op\",\r\n          left,\r\n          op: right[1].text as \"++\" | \"--\",\r\n          isAfter: true,\r\n          _isExpr: true,\r\n        },\r\n        [right[0]],\r\n      ]\r\n    ),\r\n    field_access,\r\n    function_call_generic,\r\n    primary_expression\r\n  )\r\n);\r\n\r\ninteger_expression.setPattern(expression);\r\n\r\nfunction_call.setPattern(function_call_or_method);\r\n\r\nfunction_call_or_method.setPattern(\r\n  // NOTE: THIS DIFFERS FROM THE GRAMMAR!!\r\n  // METHOD CALLS HAVE BEEN MOVED TO postfix_expression\r\n  // TO PREVENT IT FROM DEFAULTING TO PROPERTY ACCESS\r\n  alt_sc(\r\n    function_call_generic,\r\n    binop_generic(\r\n      postfix_expression,\r\n      seq(comment_parser, str(\".\"), function_call_generic),\r\n      (left, right) => [\r\n        {\r\n          type: \"function-call-field-access\",\r\n          left,\r\n          right: right[2],\r\n          _isExpr: true,\r\n        },\r\n        [right[0]],\r\n      ]\r\n    )\r\n  )\r\n);\r\n\r\nfunction_call_generic.setPattern(\r\n  nodeify_commented(\r\n    append_comments(\r\n      seq(\r\n        alt_sc(\r\n          function_call_header_with_parameters,\r\n          function_call_header_no_parameters\r\n        ),\r\n        comment_parser,\r\n        str(\")\")\r\n      ),\r\n      (s) => s[0],\r\n      (s) => [s[1]]\r\n    )\r\n  )\r\n);\r\n\r\nfunction_call_header_no_parameters.setPattern(\r\n  add_comments_and_transform(\r\n    seq(function_call_header, opt_sc(seq(comment_parser, str(\"void\")))),\r\n    (s) => s[0],\r\n    (i, s) => ({\r\n      type: \"function-call\",\r\n      identifier: i,\r\n      isVoid: s[1] !== undefined,\r\n      args: [],\r\n      _isExpr: true,\r\n    }),\r\n    (o, s) => [...o, s[1]?.[0] ?? []]\r\n  )\r\n);\r\n\r\nfunction_call_header_with_parameters.setPattern(\r\n  add_comments_and_transform(\r\n    seq(\r\n      function_call_header,\r\n      assignment_expression,\r\n      rep_sc(seq(comment_parser, str(\",\"), assignment_expression))\r\n    ),\r\n    (s) => s[0],\r\n    (i, s) => ({\r\n      type: \"function-call\",\r\n      identifier: i,\r\n      isVoid: false,\r\n      args: [s[1], ...s[2].map((e) => e[2])],\r\n      _isExpr: true,\r\n    }),\r\n    (o, s) => [...o, ...s[2].map((e) => e[0])]\r\n  )\r\n);\r\n\r\nfunction_call_header.setPattern(\r\n  append_comments(\r\n    seq(function_identifier, comment_parser, str(\"(\")),\r\n    (s) => s[0],\r\n    (s) => [s[1]]\r\n  )\r\n);\r\n\r\nfunction_identifier.setPattern(\r\n  alt_sc(\r\n    type_specifier,\r\n    with_comment_before(\r\n      apply(tok(TokenKind.Identifier), (s) => ({\r\n        type: \"function-identifier\",\r\n        identifier: s.text,\r\n      }))\r\n    )\r\n  )\r\n);\r\n\r\nunary_expression.setPattern(\r\n  alt_sc(\r\n    postfix_expression,\r\n    nodeify(\r\n      apply(\r\n        seq(\r\n          alt_sc(str(\"--\"), str(\"++\"), str(\"+\"), str(\"-\"), str(\"!\"), str(\"~\")),\r\n          unary_expression\r\n        ),\r\n        ([expr, left]) => ({\r\n          type: \"unary-op\",\r\n          op: expr.text as \"++\" | \"--\",\r\n          left,\r\n          isAfter: false,\r\n          _isExpr: true,\r\n        })\r\n      )\r\n    )\r\n  )\r\n);\r\n\r\nmultiplicative_expression.setPattern(\r\n  binop(\r\n    unary_expression,\r\n    multiplicative_expression,\r\n    alt_sc(lstr(\"*\"), lstr(\"/\"), lstr(\"%\"))\r\n  )\r\n);\r\n\r\nadditive_expression.setPattern(\r\n  binop(\r\n    multiplicative_expression,\r\n    additive_expression,\r\n    alt_sc(lstr(\"+\"), lstr(\"-\"))\r\n  )\r\n);\r\n\r\nshift_expression.setPattern(\r\n  binop(additive_expression, shift_expression, alt_sc(lstr(\">>\"), lstr(\"<<\")))\r\n);\r\n\r\nrelational_expression.setPattern(\r\n  binop(\r\n    shift_expression,\r\n    relational_expression,\r\n    alt_sc(lstr(\">\"), lstr(\"<\"), lstr(\">=\"), lstr(\"<=\"))\r\n  )\r\n);\r\n\r\nequality_expression.setPattern(\r\n  binop(\r\n    relational_expression,\r\n    equality_expression,\r\n    alt_sc(lstr(\"==\"), lstr(\"!=\"))\r\n  )\r\n);\r\n\r\nand_expression.setPattern(\r\n  binop(equality_expression, and_expression, lstr(\"&\"))\r\n);\r\n\r\nexclusive_or_expression.setPattern(\r\n  binop(and_expression, exclusive_or_expression, lstr(\"^\"))\r\n);\r\n\r\ninclusive_or_expression.setPattern(\r\n  binop(exclusive_or_expression, inclusive_or_expression, lstr(\"|\"))\r\n);\r\n\r\nlogical_and_expression.setPattern(\r\n  binop(inclusive_or_expression, logical_and_expression, lstr(\"&&\"))\r\n);\r\n\r\nlogical_xor_expression.setPattern(\r\n  binop(logical_and_expression, logical_xor_expression, lstr(\"^^\"))\r\n);\r\n\r\nlogical_or_expression.setPattern(\r\n  binop(logical_xor_expression, logical_or_expression, lstr(\"||\"))\r\n);\r\n\r\nconditional_expression.setPattern(\r\n  alt_sc(\r\n    nodeify_commented(\r\n      commentify(\r\n        seq(\r\n          logical_or_expression,\r\n          comment_parser,\r\n          str(\"?\"),\r\n          expression,\r\n          comment_parser,\r\n          str(\":\"),\r\n          assignment_expression\r\n        ),\r\n        (l) =>\r\n          ({\r\n            type: \"conditional\",\r\n            condition: l[0],\r\n            ifTrue: l[3],\r\n            ifFalse: l[6],\r\n          } as ConditionalExpr),\r\n        (l) => [l[1], l[4]]\r\n      )\r\n    ),\r\n    logical_or_expression\r\n  )\r\n);\r\n\r\nassignment_expression.setPattern(\r\n  alt_sc(\r\n    nodeify_commented(\r\n      commentify(\r\n        seq(\r\n          unary_expression,\r\n          comment_parser,\r\n          assignment_operator,\r\n          assignment_expression\r\n        ),\r\n        (l) => ({\r\n          type: \"assignment\",\r\n          left: l[0],\r\n          right: l[3],\r\n          op: l[2],\r\n          _isExpr: true,\r\n        }),\r\n        (l) => [l[1]]\r\n      )\r\n    ),\r\n    conditional_expression\r\n  )\r\n);\r\n\r\nassignment_operator.setPattern(\r\n  alt_sc(\r\n    lstr(\"=\"),\r\n    lstr(\"*=\"),\r\n    lstr(\"/=\"),\r\n    lstr(\"%=\"),\r\n    lstr(\"+=\"),\r\n    lstr(\"-=\"),\r\n    lstr(\"<<=\"),\r\n    lstr(\">>=\"),\r\n    lstr(\"&=\"),\r\n    lstr(\"^=\"),\r\n    lstr(\"|=\")\r\n  )\r\n);\r\n\r\nexpression.setPattern(binop(assignment_expression, expression, lstr(\",\")));\r\n\r\nconstant_expression.setPattern(conditional_expression);\r\n\r\ndeclaration.setPattern(\r\n  alt_sc(\r\n    commentify(\r\n      seq(init_declarator_list, comment_parser, str(\";\")),\r\n      (s) =>\r\n        ({\r\n          type: \"declarator-list\",\r\n          declaratorList: s[0],\r\n          _isDecl: true,\r\n        } satisfies Declaration),\r\n      (s) => [s[1]]\r\n    ),\r\n    commentify(\r\n      seq(\r\n        apply(type_qualifier, (x) => x),\r\n        with_comment_before(apply(tok(TokenKind.Identifier), (t) => t.text)),\r\n        comment_parser,\r\n        str(\"{\"),\r\n        struct_declaration_list,\r\n        comment_parser,\r\n        str(\"}\"),\r\n        opt_sc(\r\n          seq(\r\n            with_comment_before(\r\n              apply(tok(TokenKind.Identifier), (t) => t.text)\r\n            ),\r\n            opt_sc(\r\n              seq(\r\n                comment_parser,\r\n                str(\"[\"),\r\n                constant_expression,\r\n                comment_parser,\r\n                str(\"]\")\r\n              )\r\n            )\r\n          )\r\n        ),\r\n        comment_parser,\r\n        str(\";\")\r\n      ),\r\n      (s) =>\r\n        ({\r\n          type: \"struct\",\r\n          typeQualifier: s[0],\r\n          name: s[1],\r\n          name2: s[7]?.[0],\r\n          declarationList: s[4],\r\n          constantExpr: s[7]?.[1]?.[2],\r\n          _isDecl: true,\r\n        } satisfies Declaration),\r\n      (s) => [s[2], s[5], ...(s[7]?.[1] ? [s[7][1][0], s[7][1][3]] : []), s[8]]\r\n    ),\r\n    commentify(\r\n      seq(function_prototype, comment_parser, str(\";\")),\r\n      (s) => ({ type: \"function-prototype\", prototype: s[0], _isDecl: true }),\r\n      (s) => [s[1]]\r\n    ),\r\n    commentify(\r\n      seq(\r\n        str(\"precision\"),\r\n        precision_qualifier,\r\n        type_specifier_no_prec,\r\n        comment_parser,\r\n        str(\";\")\r\n      ),\r\n      (s) =>\r\n        ({\r\n          type: \"type-specifier\",\r\n          precision: s[1],\r\n          specifier: s[2],\r\n          _isDecl: true,\r\n        } satisfies Declaration),\r\n      (s) => [s[3]]\r\n    ),\r\n    commentify(\r\n      seq(type_qualifier, comment_parser, str(\";\")),\r\n      (s) => ({\r\n        type: \"type-qualifier\",\r\n        typeQualifier: s[0],\r\n        _isDecl: true,\r\n      }),\r\n      (s) => [s[1]]\r\n    )\r\n  )\r\n);\r\n\r\nfunction_prototype.setPattern(\r\n  add_comments_and_transform(\r\n    seq(function_declarator, comment_parser, str(\")\")),\r\n    (s) => s[0],\r\n    (v) => v,\r\n    (oc, s) => [...oc, s[1]]\r\n  )\r\n);\r\n\r\nfunction_declarator.setPattern(\r\n  alt_sc(function_header_with_parameters, function_header)\r\n);\r\n\r\nfunction_header_with_parameters.setPattern(\r\n  add_comments_and_transform(\r\n    seq(\r\n      function_header,\r\n      commentify(\r\n        seq(\r\n          parameter_declaration,\r\n          rep_sc(seq(comment_parser, str(\",\"), parameter_declaration))\r\n        ),\r\n        (s) =>\r\n          [s[0], ...s[1].map((v) => v[2])] as Commented<ParameterDeclaration>[],\r\n        (s) => s[1].map((v) => v[0])\r\n      )\r\n    ),\r\n    (s) => s[0],\r\n    (fh, s) => ({\r\n      ...fh,\r\n      parameters: s[1],\r\n    }),\r\n    (oc) => oc\r\n  )\r\n);\r\n\r\nfunction_header.setPattern(\r\n  commentify(\r\n    seq(\r\n      fully_specified_type,\r\n      with_comment_before(apply(tok(TokenKind.Identifier), (t) => t.text)),\r\n      comment_parser,\r\n      str(\"(\")\r\n    ),\r\n    (s) =>\r\n      ({\r\n        fullySpecifiedType: s[0],\r\n        name: s[1],\r\n      } as FunctionHeader),\r\n    (s) => [s[2]]\r\n  )\r\n);\r\n\r\nparameter_declarator.setPattern(\r\n  commentify(\r\n    seq(\r\n      type_specifier,\r\n      with_comment_before(apply(tok(TokenKind.Identifier), (t) => t.text)),\r\n      opt_sc(seq(str(\"[\"), constant_expression, comment_parser, str(\"]\")))\r\n    ),\r\n    (s) => ({\r\n      typeSpecifier: s[0],\r\n      identifier: s[1],\r\n      arraySize: s[2]?.[1],\r\n    }),\r\n    (s) => [s[2]?.[2] ?? []]\r\n  )\r\n);\r\n\r\nparameter_declaration.setPattern(\r\n  with_comment_before(\r\n    apply(\r\n      seq(\r\n        opt_sc(parameter_type_qualifier),\r\n        parameter_qualifier,\r\n        alt_sc(\r\n          apply(parameter_declarator, (pd) => ({\r\n            type: \"declarator\",\r\n            declarator: pd,\r\n          })),\r\n          apply(parameter_type_specifier, (pts) => ({\r\n            type: \"specifier\",\r\n            specifier: pts,\r\n          }))\r\n        )\r\n      ),\r\n      ([ptq, pq, dos]) =>\r\n        ({\r\n          parameterTypeQualifier: ptq,\r\n          parameterQualifier: pq,\r\n          declaratorOrSpecifier: dos,\r\n        } as ParameterDeclaration)\r\n    )\r\n  )\r\n);\r\n\r\nparameter_qualifier.setPattern(\r\n  alt_sc(nodeify(alt_sc(lstr(\"in\"), lstr(\"out\"), lstr(\"inout\"))), nil())\r\n);\r\n\r\nparameter_type_specifier.setPattern(type_specifier);\r\n\r\n// custom rule for convenience\r\nconst identifier_declaration: Parser<\r\n  TokenKind,\r\n  Commented<SingleDeclaration>\r\n> = commentify(\r\n  seq(\r\n    with_comment_before(apply(tok(TokenKind.Identifier), (t) => t.text)),\r\n    alt_sc(\r\n      commentify(\r\n        seq(str(\"[\"), constant_expression, comment_parser, str(\"]\")),\r\n        (s) =>\r\n          ({\r\n            type: \"sized-array\",\r\n            size: s[1],\r\n          } satisfies SingleDeclarationVariant),\r\n        (s) => [s[2]]\r\n      ),\r\n      commentify(\r\n        seq(\r\n          str(\"[\"),\r\n          opt_sc(constant_expression),\r\n          comment_parser,\r\n          str(\"]\"),\r\n          comment_parser,\r\n          str(\"=\"),\r\n          initializer\r\n        ),\r\n        (s) =>\r\n          ({\r\n            type: \"initialized-array\",\r\n            size: s[1],\r\n            initializer: s[6],\r\n          } satisfies SingleDeclarationVariant),\r\n        (s) => [s[2], s[4]]\r\n      ),\r\n      commentify(\r\n        seq(comment_parser, str(\"=\"), initializer),\r\n        (s) =>\r\n          ({\r\n            type: \"initialized\",\r\n            initializer: s[2],\r\n          } satisfies SingleDeclarationVariant),\r\n        (s) => [s[0]]\r\n      ),\r\n      nil()\r\n    )\r\n  ),\r\n  (s) => ({\r\n    name: s[0],\r\n    variant: s[1],\r\n  }),\r\n  (s) => []\r\n);\r\n\r\ninit_declarator_list.setPattern(\r\n  with_comment_before(\r\n    apply(\r\n      seq(\r\n        alt_sc(\r\n          with_comment_before(\r\n            apply(\r\n              fully_specified_type,\r\n              (s) =>\r\n                ({\r\n                  type: \"type\",\r\n                  declType: s,\r\n                } satisfies SingleDeclarationStart)\r\n            )\r\n          ),\r\n          with_comment_before(\r\n            apply(\r\n              str(\"invariant\"),\r\n              (s) => ({ type: \"invariant\" } satisfies SingleDeclarationStart)\r\n            )\r\n          )\r\n        ),\r\n        commentify(\r\n          opt_sc(\r\n            seq(\r\n              identifier_declaration,\r\n              rep_sc(seq(comment_parser, str(\",\"), identifier_declaration))\r\n            )\r\n          ),\r\n          (s) => (s ? [s[0], ...s[1].map((e) => e[2])] : []),\r\n          (s) => (s ? s[1].map((e) => e[0]) : [])\r\n        )\r\n      ),\r\n      (s) => ({\r\n        init: s[0],\r\n        declarations: s[1],\r\n      })\r\n    )\r\n  )\r\n);\r\n\r\n// not even implementing this one tbh\r\n// no need lol\r\nsingle_declaration;\r\n\r\nfully_specified_type.setPattern(\r\n  with_comment_before(\r\n    apply(\r\n      seq(opt_sc(type_qualifier), type_specifier),\r\n      ([qualifier, specifier]) => ({\r\n        specifier,\r\n        qualifier,\r\n      })\r\n    )\r\n  )\r\n);\r\n\r\ninvariant_qualifier.setPattern(with_comment_before(lstr(\"invariant\")));\r\n\r\ninterpolation_qualifier.setPattern(\r\n  with_comment_before(alt_sc(lstr(\"smooth\"), lstr(\"flat\")))\r\n);\r\n\r\nlayout_qualifier.setPattern(\r\n  add_comments_and_transform(\r\n    seq(\r\n      str(\"layout\"),\r\n      comment_parser,\r\n      str(\"(\"),\r\n      layout_qualifier_id_list,\r\n      comment_parser,\r\n      str(\")\")\r\n    ),\r\n    (s) => s[3],\r\n    (d, s) => d,\r\n    (o, s) => [s[1], ...o, s[4]]\r\n  )\r\n);\r\n\r\nlayout_qualifier_id_list.setPattern(\r\n  commentify(\r\n    seq(\r\n      layout_qualifier_id,\r\n      rep_sc(seq(comment_parser, lstr(\",\"), layout_qualifier_id))\r\n    ),\r\n    (s) => [s[0], ...s[1].map((e) => e[2])],\r\n    (s) => s[1].map((e) => e[0])\r\n  )\r\n);\r\n\r\nlayout_qualifier_id.setPattern(\r\n  alt_sc(\r\n    commentify(\r\n      seq(\r\n        tok(TokenKind.Identifier),\r\n        comment_parser,\r\n        str(\"=\"),\r\n        comment_parser,\r\n        alt_sc(\r\n          tok(TokenKind.IntegerDecimal),\r\n          tok(TokenKind.IntegerHex),\r\n          tok(TokenKind.IntegerOctal)\r\n        )\r\n      ),\r\n      (s) => ({\r\n        identifier: s[0].text,\r\n        value: glslParseInt(s[4].text),\r\n      }),\r\n      (s) => [s[1], s[3]]\r\n    ),\r\n    with_comment_before(\r\n      apply(alt_sc(tok(TokenKind.Identifier), tok(TokenKind.Keyword)), (i) => ({\r\n        identifier: i.text,\r\n      }))\r\n    )\r\n  )\r\n);\r\n\r\nparameter_type_qualifier.setPattern(with_comment_before(lstr(\"const\")));\r\n\r\ntype_qualifier.setPattern(\r\n  alt_sc(\r\n    // storage_qualifier\r\n    with_comment_before(\r\n      apply(storage_qualifier, (q) => ({\r\n        type: \"sq\",\r\n        storageQualifier: q,\r\n      }))\r\n    ),\r\n    // layout_qualifier\r\n    // layout_qualifier storage_qualifier\r\n    with_comment_before(\r\n      apply(seq(layout_qualifier, opt_sc(storage_qualifier)), ([lq, sq]) => ({\r\n        type: \"lq-sq\",\r\n        layoutQualifier: lq,\r\n        storageQualifier: sq,\r\n      }))\r\n    ),\r\n    // interpolation_qualifier storage_qualifier\r\n    // interpolation_qualifier\r\n    with_comment_before(\r\n      apply(\r\n        seq(interpolation_qualifier, opt_sc(storage_qualifier)),\r\n        ([iq, sq]) => ({\r\n          type: \"intq-sq\",\r\n          interpolationQualifier: iq,\r\n          storageQualifier: sq,\r\n        })\r\n      )\r\n    ),\r\n    // invariant_qualifier storage_qualifier\r\n    // invariant_qualifier interpolation_qualifier storage_qualifier\r\n    with_comment_before(\r\n      apply(\r\n        seq(\r\n          invariant_qualifier,\r\n          opt_sc(interpolation_qualifier),\r\n          storage_qualifier\r\n        ),\r\n        ([invq, intq, sq]) => ({\r\n          type: \"invq-intq-sq\",\r\n          interpolationQualifier: intq,\r\n          invariantQualifier: invq,\r\n          storageQualifier: sq,\r\n        })\r\n      )\r\n    )\r\n  )\r\n);\r\n\r\nstorage_qualifier.setPattern(\r\n  with_comment_before(\r\n    alt_sc(\r\n      lstr(\"const\"),\r\n      lstr(\"in\"),\r\n      lstr(\"out\"),\r\n      apply(seq(str(\"centroid\"), str(\"in\")), () => \"centroid in\"),\r\n      apply(seq(str(\"centroid\"), str(\"out\")), () => \"centroid out\"),\r\n      lstr(\"uniform\")\r\n    )\r\n  )\r\n);\r\n\r\ntype_specifier.setPattern(\r\n  commentify(\r\n    seq(opt_sc(precision_qualifier), type_specifier_no_prec),\r\n    ([precision, specifier]) =>\r\n      ({\r\n        type: \"type-specifier\",\r\n        specifier,\r\n        precision,\r\n      } as TypeSpecifier),\r\n    (s) => []\r\n  )\r\n);\r\n\r\ntype_specifier_no_prec.setPattern(\r\n  commentify(\r\n    seq(\r\n      type_specifier_nonarray,\r\n      opt_sc(\r\n        seq(\r\n          comment_parser,\r\n          seq(str(\"[\"), opt_sc(constant_expression), comment_parser, str(\"]\"))\r\n        )\r\n      )\r\n    ),\r\n    (s) =>\r\n      ({\r\n        typeName: s[0],\r\n        arrayType: s[1]\r\n          ? s[1][1][1]\r\n            ? { type: \"static\", size: s[1][1][1] }\r\n            : { type: \"dynamic\" }\r\n          : { type: \"none\" },\r\n      } as TypeNoPrec),\r\n    (s) => (s[1] ? [s[1][0], s[1][1][2]] : [])\r\n  )\r\n);\r\n\r\ntype_specifier_nonarray.setPattern(\r\n  with_comment_before(\r\n    alt_sc(\r\n      apply(\r\n        with_comment_before(\r\n          alt_sc(\r\n            alt_sc(\r\n              lstr(\"void\"),\r\n              lstr(\"float\"),\r\n              lstr(\"int\"),\r\n              lstr(\"uint\"),\r\n              lstr(\"bool\"),\r\n              lstr(\"vec2\"),\r\n              lstr(\"vec3\"),\r\n              lstr(\"vec4\"),\r\n              lstr(\"bvec2\"),\r\n              lstr(\"bvec3\"),\r\n              lstr(\"bvec4\"),\r\n              lstr(\"ivec2\"),\r\n              lstr(\"ivec3\"),\r\n              lstr(\"ivec4\"),\r\n              lstr(\"uvec2\"),\r\n              lstr(\"uvec3\")\r\n            ),\r\n            alt_sc(\r\n              lstr(\"uvec4\"),\r\n              lstr(\"mat2\"),\r\n              lstr(\"mat3\"),\r\n              lstr(\"mat4\"),\r\n              lstr(\"mat3x2\"),\r\n              lstr(\"mat3x3\"),\r\n              lstr(\"mat3x4\"),\r\n              lstr(\"mat4x2\"),\r\n              lstr(\"mat4x3\"),\r\n              lstr(\"mat4x4\")\r\n            ),\r\n            alt_sc(\r\n              lstr(\"sampler2D\"),\r\n              lstr(\"sampler3D\"),\r\n              lstr(\"samplerCube\"),\r\n              lstr(\"sampler2DShadow\"),\r\n              lstr(\"samplerCubeShadow\"),\r\n              lstr(\"sampler2DArray\"),\r\n              lstr(\"sampler2DArrayShadow\"),\r\n              lstr(\"isampler2D\"),\r\n              lstr(\"isampler3D\"),\r\n              lstr(\"isamplerCube\"),\r\n              lstr(\"isampler2DArray\"),\r\n              lstr(\"usampler2D\"),\r\n              lstr(\"usampler3D\"),\r\n              lstr(\"usamplerCube\"),\r\n              lstr(\"usampler2DArray\")\r\n            )\r\n          )\r\n        ),\r\n        (s) => ({\r\n          type: \"builtin\",\r\n          name: s,\r\n        })\r\n      ),\r\n      apply(struct_specifier, (s) => ({\r\n        type: \"struct\",\r\n        struct: s,\r\n      })),\r\n      apply(\r\n        with_comment_before(apply(tok(TokenKind.Identifier), (s) => s.text)),\r\n        (s) =>\r\n          ({\r\n            type: \"custom\",\r\n            name: s,\r\n          } satisfies TypeSpecifierNonarray)\r\n      )\r\n    )\r\n  )\r\n);\r\n\r\nprecision_qualifier.setPattern(\r\n  with_comment_before(alt_sc(lstr(\"highp\"), lstr(\"mediump\"), lstr(\"lowp\")))\r\n);\r\n\r\nstruct_specifier.setPattern(\r\n  commentify(\r\n    seq(\r\n      str(\"struct\"),\r\n      opt_sc(\r\n        with_comment_before(apply(tok(TokenKind.Identifier), (t) => t.text))\r\n      ),\r\n      comment_parser,\r\n      str(\"{\"),\r\n      struct_declaration_list,\r\n      comment_parser,\r\n      str(\"}\")\r\n    ),\r\n    (s) => ({\r\n      members: s[4],\r\n      name: s[1],\r\n      _isStruct: true,\r\n    }),\r\n    (s) => [s[2], s[5]]\r\n  )\r\n);\r\n\r\nstruct_declaration_list.setPattern(\r\n  with_comment_before(rep_sc(struct_declaration))\r\n);\r\n\r\nstruct_declaration.setPattern(\r\n  commentify(\r\n    seq(\r\n      opt_sc(type_qualifier),\r\n      type_specifier,\r\n      struct_declarator_list,\r\n      comment_parser,\r\n      str(\";\")\r\n    ),\r\n    (s) => ({\r\n      typeQualifier: s[0],\r\n      typeSpecifier: s[1],\r\n      declaratorList: s[2],\r\n    }),\r\n    (s) => [s[3]]\r\n  )\r\n);\r\n\r\nstruct_declarator_list.setPattern(\r\n  commentify(\r\n    seq(\r\n      struct_declarator,\r\n      rep_sc(seq(comment_parser, str(\",\"), struct_declarator))\r\n    ),\r\n    (s) => [s[0], ...s[1].map((e) => e[2])],\r\n    (s) => s[1].map((e) => e[0])\r\n  )\r\n);\r\n\r\nstruct_declarator.setPattern(\r\n  commentify(\r\n    seq(\r\n      tok(TokenKind.Identifier),\r\n      opt_sc(\r\n        seq(\r\n          comment_parser,\r\n          str(\"[\"),\r\n          opt_sc(constant_expression),\r\n          comment_parser,\r\n          str(\"]\")\r\n        )\r\n      )\r\n    ),\r\n    (s) =>\r\n      ({\r\n        name: s[0].text,\r\n        isArray: s[1]\r\n          ? {\r\n              expr: s[1]?.[2],\r\n            }\r\n          : undefined,\r\n      } as StructDeclarator),\r\n    (s) => (s[1] ? [s[1][0], s[1][3]] : [])\r\n  )\r\n);\r\n\r\ninitializer.setPattern(assignment_expression);\r\n\r\ndeclaration_statement.setPattern(\r\n  nodeify(\r\n    apply(\r\n      declaration,\r\n      (decl) =>\r\n        ({\r\n          type: \"declaration\",\r\n          decl,\r\n          _isStmt: true,\r\n        } satisfies Stmt)\r\n    )\r\n  )\r\n);\r\n\r\nstatement.setPattern(alt_sc(compound_statement_with_scope, simple_statement));\r\n\r\nstatement_no_new_scope.setPattern(\r\n  alt_sc(compound_statement_no_new_scope, simple_statement)\r\n);\r\n\r\nstatement_with_scope.setPattern(\r\n  alt_sc(compound_statement_no_new_scope, simple_statement)\r\n);\r\n\r\nsimple_statement.setPattern(\r\n  alt_sc(\r\n    expression_statement,\r\n    declaration_statement,\r\n    selection_statement,\r\n    switch_statement,\r\n    case_label,\r\n    iteration_statement,\r\n    jump_statement\r\n  )\r\n);\r\n\r\ncompound_statement_with_scope.setPattern(compound_statement_no_new_scope);\r\n\r\ncompound_statement_no_new_scope.setPattern(\r\n  nodeify_commented(\r\n    commentify(\r\n      seq(str(\"{\"), opt_sc(statement_list), comment_parser, str(\"}\")),\r\n      (s) => ({ type: \"compound\", statements: s[1] ?? [], _isStmt: true }),\r\n      (s) => [s[2]]\r\n    )\r\n  )\r\n);\r\n\r\nstatement_list.setPattern(\r\n  apply(seq(statement, rep_sc(statement)), ([stmt1, rest]) => [stmt1, ...rest])\r\n);\r\n\r\nexpression_statement.setPattern(\r\n  nodeify_commented(\r\n    commentify(\r\n      seq(opt_sc(expression), comment_parser, str(\";\")),\r\n      (s) => ({\r\n        type: \"expr\",\r\n        expr: s[0],\r\n        _isStmt: true,\r\n      }),\r\n      (s) => [s[1]]\r\n    )\r\n  )\r\n);\r\n\r\nselection_statement.setPattern(\r\n  nodeify_commented(\r\n    commentify(\r\n      seq(\r\n        str(\"if\"),\r\n        comment_parser,\r\n        str(\"(\"),\r\n        expression,\r\n        comment_parser,\r\n        str(\")\"),\r\n        selection_rest_statement\r\n      ),\r\n      (s) => ({\r\n        type: \"selection\",\r\n        cond: s[3],\r\n        rest: s[6],\r\n        _isStmt: true,\r\n      }),\r\n      (s) => [s[1], s[4]]\r\n    )\r\n  )\r\n);\r\n\r\nselection_rest_statement.setPattern(\r\n  commentify(\r\n    seq(\r\n      statement_with_scope,\r\n      opt_sc(seq(comment_parser, str(\"else\"), statement_with_scope))\r\n    ),\r\n    (s) => ({\r\n      if: s[0],\r\n      else: s[1]?.[2],\r\n      _isStmt: true,\r\n    }),\r\n    (s) => (s[1] ? [s[1][0]] : [])\r\n  )\r\n);\r\n\r\ncondition.setPattern(\r\n  alt_sc(\r\n    with_comment_before(apply(expression, (s) => ({ type: \"expr\", expr: s }))),\r\n    commentify(\r\n      seq(\r\n        fully_specified_type,\r\n        with_comment_before(apply(tok(TokenKind.Identifier), (t) => t.text)),\r\n        comment_parser,\r\n        str(\"=\"),\r\n        initializer\r\n      ),\r\n      (s) =>\r\n        ({\r\n          type: \"type-equal-init\",\r\n          fullySpecifiedType: s[0],\r\n          name: s[1],\r\n          initializer: s[4],\r\n        } as Condition),\r\n      (s) => [s[2]]\r\n    )\r\n  )\r\n);\r\n\r\nswitch_statement.setPattern(\r\n  nodeify_commented(\r\n    commentify(\r\n      seq(\r\n        str(\"switch\"),\r\n        comment_parser,\r\n        str(\"(\"),\r\n        expression,\r\n        comment_parser,\r\n        str(\")\"),\r\n        comment_parser,\r\n        str(\"{\"),\r\n        switch_statement_list,\r\n        comment_parser,\r\n        str(\"}\")\r\n      ),\r\n      (s) =>\r\n        ({\r\n          type: \"switch\",\r\n          expr: s[3],\r\n          stmts: s[8] ?? [],\r\n          _isStmt: true,\r\n        } satisfies SwitchStmt),\r\n      (s) => [s[1], s[4], s[6], s[9]]\r\n    )\r\n  )\r\n);\r\n\r\nswitch_statement_list.setPattern(opt_sc(statement_list));\r\n\r\ncase_label.setPattern(\r\n  nodeify_commented(\r\n    alt_sc(\r\n      commentify(\r\n        seq(str(\"case\"), expression, comment_parser, str(\":\")),\r\n        (s) => ({ type: \"case\", expr: s[1], _isStmt: true } as Stmt),\r\n        (s) => [s[2]]\r\n      ),\r\n      commentify(\r\n        seq(str(\"default\"), comment_parser, str(\":\")),\r\n        (s) => ({ type: \"default-case\", _isStmt: true }),\r\n        (s) => [s[1]]\r\n      )\r\n    )\r\n  )\r\n);\r\n\r\niteration_statement.setPattern(\r\n  nodeify_commented(\r\n    alt_sc(\r\n      commentify(\r\n        seq(\r\n          str(\"while\"),\r\n          comment_parser,\r\n          str(\"(\"),\r\n          condition,\r\n          comment_parser,\r\n          str(\")\"),\r\n          statement_no_new_scope\r\n        ),\r\n        (s) =>\r\n          ({\r\n            type: \"while\",\r\n            cond: s[3],\r\n            body: s[6],\r\n            _isStmt: true,\r\n          } as IterationStmt),\r\n        (s) => [s[1], s[4]]\r\n      ),\r\n      commentify(\r\n        seq(\r\n          str(\"do\"),\r\n          statement_with_scope,\r\n          comment_parser,\r\n          str(\"while\"),\r\n          comment_parser,\r\n          str(\"(\"),\r\n          expression,\r\n          comment_parser,\r\n          str(\")\"),\r\n          comment_parser,\r\n          str(\";\")\r\n        ),\r\n        (s) =>\r\n          ({\r\n            type: \"do-while\",\r\n            cond: s[6],\r\n            body: s[1],\r\n            _isStmt: true,\r\n          } as IterationStmt),\r\n        (s) => [s[2], s[4], s[7], s[9]]\r\n      ),\r\n      commentify(\r\n        seq(\r\n          str(\"for\"),\r\n          comment_parser,\r\n          str(\"(\"),\r\n          for_init_statement,\r\n          for_rest_statement,\r\n          comment_parser,\r\n          str(\")\"),\r\n          statement_no_new_scope\r\n        ),\r\n        (s) => ({\r\n          type: \"for\",\r\n          init: s[3],\r\n          rest: s[4],\r\n          body: s[7],\r\n          _isStmt: true,\r\n        }),\r\n        (s) => [s[1], s[5]]\r\n      )\r\n    )\r\n  )\r\n);\r\n\r\nfor_init_statement.setPattern(\r\n  alt_sc(expression_statement, declaration_statement)\r\n);\r\n\r\nconditionopt.setPattern(alt_sc(condition, nil()));\r\n\r\nfor_rest_statement.setPattern(\r\n  commentify(\r\n    seq(conditionopt, comment_parser, str(\";\"), opt_sc(expression)),\r\n    (s) => ({\r\n      condition: s[0],\r\n      expr: s[3],\r\n    }),\r\n    (s) => [s[1]]\r\n  )\r\n);\r\n\r\njump_statement.setPattern(\r\n  nodeify_commented(\r\n    alt_sc(\r\n      commentify(\r\n        seq(\r\n          alt_sc(lstr(\"continue\"), lstr(\"break\"), lstr(\"discard\")),\r\n          comment_parser,\r\n          str(\";\")\r\n        ),\r\n        (s) => ({ type: s[0], _isStmt: true } as Stmt),\r\n        (s) => [s[1]]\r\n      ),\r\n      commentify(\r\n        seq(str(\"return\"), opt_sc(expression), comment_parser, str(\";\")),\r\n        (s) => ({ type: \"return\", expr: s[1], _isStmt: true } satisfies Stmt),\r\n        (s) => [s[2]]\r\n      )\r\n    )\r\n  )\r\n);\r\n\r\ntranslation_unit.setPattern(\r\n  commentify_no_comments_before(\r\n    seq(rep_sc(external_declaration), comment_parser),\r\n    (s) => s[0],\r\n    (s) => [s[1]]\r\n  )\r\n);\r\n\r\nconst import_option: Parser<\r\n  TokenKind,\r\n  ASTNode<SingleItemImport>\r\n> = nodeify_commented(\r\n  commentify(\r\n    seq(\r\n      tok(TokenKind.Identifier),\r\n      opt_sc(\r\n        seq(\r\n          comment_parser,\r\n          str(\"as\"),\r\n          comment_parser,\r\n          tok(TokenKind.Identifier)\r\n        )\r\n      )\r\n    ),\r\n    (s) =>\r\n      ({ name: s[0].text, alias: s[1]?.[3].text } satisfies SingleItemImport),\r\n    (s) => (s[1] ? [s[1][0], s[1][2]] : [])\r\n  )\r\n);\r\n\r\nconst import_decl: Parser<\r\n  TokenKind,\r\n  ASTNode<ExternalDeclarationImport>\r\n> = nodeify_commented(\r\n  commentify(\r\n    seq(\r\n      str(\"import\"),\r\n      comment_parser,\r\n      alt_sc(\r\n        commentify(\r\n          seq(\r\n            str(\"*\"),\r\n            opt_sc(\r\n              seq(\r\n                comment_parser,\r\n                str(\"as\"),\r\n                comment_parser,\r\n                tok(TokenKind.Identifier)\r\n              )\r\n            )\r\n          ),\r\n          (s) =>\r\n            ({ type: \"all\", prefix: s[1]?.[3]?.text ?? \"\" } satisfies Imports),\r\n          (s) => (s[1] ? [s[1][0], s[1][2]] : [])\r\n        ),\r\n        commentify(\r\n          seq(\r\n            str(\"{\"),\r\n            opt_sc(\r\n              seq(\r\n                import_option,\r\n                rep_sc(seq(comment_parser, str(\",\"), import_option))\r\n              )\r\n            ),\r\n            comment_parser,\r\n            str(\"}\")\r\n          ),\r\n          (s) =>\r\n            ({\r\n              type: \"some\",\r\n              imports: s[1]\r\n                ? [s[1][0], ...(s[1][1].map((e) => e[2]) ?? [])]\r\n                : [],\r\n            } satisfies Imports),\r\n          (s) => [...(s[1]?.[1].map((s) => s[0]) ?? []), s[2]]\r\n        )\r\n      ),\r\n      comment_parser,\r\n      str(\"from\"),\r\n      comment_parser,\r\n      tok(TokenKind.ImportString),\r\n      comment_parser,\r\n      str(\";\")\r\n    ),\r\n    (s) =>\r\n      ({\r\n        type: \"import\",\r\n        imports: s[2],\r\n        from: s[6].text.slice(1, -1),\r\n      } satisfies ExternalDeclarationImport),\r\n    (s) => [s[1], s[5], s[7]]\r\n  )\r\n);\r\n\r\nexternal_declaration.setPattern(\r\n  alt_sc(\r\n    import_decl,\r\n    function_definition,\r\n    nodeify(\r\n      apply(declaration, (s) => ({\r\n        type: \"declaration\",\r\n        decl: s,\r\n        _isExtDecl: true,\r\n      }))\r\n    )\r\n  )\r\n);\r\n\r\nfunction_definition.setPattern(\r\n  nodeify_commented(\r\n    commentify(\r\n      seq(function_prototype, compound_statement_no_new_scope),\r\n      (s) => ({\r\n        type: \"function\",\r\n        prototype: s[0],\r\n        body: s[1],\r\n        _isExtDecl: true,\r\n      }),\r\n      (s) => []\r\n    )\r\n  )\r\n);\r\n", "// how to ensure that comments will always be counted?:\r\n// make sure that all sequences of tokens (i.e. ones that can contain comments)\r\n// always ALWAYS allow for interleaving of comments\r\n// for instance this means no seq allowed and no rep allowed.\r\n// both of these must instead either manually interleave comments\r\n// or I must make versions that automatically do it.\r\n\r\nimport {\r\n  alt_sc,\r\n  apply,\r\n  lrec,\r\n  lrec_sc,\r\n  Parser,\r\n  rep,\r\n  rep_sc,\r\n  seq,\r\n  tok,\r\n} from \"typescript-parsec\";\r\nimport { TokenKind } from \"./lexer\";\r\nimport { ASTNode, BinaryOpExpr, Comment, Commented } from \"./parser\";\r\n\r\nexport function seq_interleave<I, TKind, T1, T2>(\r\n  i: Parser<TKind, I>,\r\n  p1: Parser<TKind, T1>,\r\n  p2: Parser<TKind, T2>\r\n): Parser<TKind, [T1, I, T2]>;\r\n\r\nexport function seq_interleave<I, TKind, T1, T2, T3>(\r\n  i: Parser<TKind, I>,\r\n  p1: Parser<TKind, T1>,\r\n  p2: Parser<TKind, T2>,\r\n  p3: Parser<TKind, T3>\r\n): Parser<TKind, [T1, I, T2, I, T3]>;\r\n\r\nexport function seq_interleave<I, TKind, T1, T2, T3, T4>(\r\n  i: Parser<TKind, I>,\r\n  p1: Parser<TKind, T1>,\r\n  p2: Parser<TKind, T2>,\r\n  p3: Parser<TKind, T3>,\r\n  p4: Parser<TKind, T4>\r\n): Parser<TKind, [T1, I, T2, I, T3, I, T4]>;\r\n\r\nexport function seq_interleave(\r\n  i: Parser<void, {}>,\r\n  ...ps: Parser<void, {}>[]\r\n): Parser<void, {}> {\r\n  return seq(\r\n    ps[0],\r\n    // @ts-expect-error yeah im not trusting typescript to be able to infer this lol\r\n    ...ps\r\n      .slice(1)\r\n      .map((p) => [i, p])\r\n      .flat(1)\r\n  );\r\n}\r\n\r\nexport const rep_interleave_sc = lrec_sc;\r\n\r\nexport const comment_parser = apply(rep_sc(tok(TokenKind.Comment)), (c) =>\r\n  c.map((c) => ({ comment: c.text } as Comment))\r\n);\r\n\r\nexport function comment_before<T1>(p: Parser<TokenKind, T1>) {\r\n  return seq(comment_parser, p);\r\n}\r\n\r\nexport function with_comment_before<T>(p: Parser<TokenKind, T>) {\r\n  return commentify<T, T>(\r\n    p,\r\n    (s) => s,\r\n    (c) => []\r\n  );\r\n}\r\n\r\nexport function nodeify<T>(\r\n  p: Parser<TokenKind, T>\r\n): Parser<TokenKind, ASTNode<T>> {\r\n  return apply(comment_before(p), ([comments, data], [start, end]) => ({\r\n    data,\r\n    comments: [comments],\r\n    range: { start: start?.pos.index!, end: end?.pos.index! },\r\n    _isNode: true,\r\n  }));\r\n}\r\n\r\nexport function nodeify_commented<T>(\r\n  p: Parser<TokenKind, Commented<T>>\r\n): Parser<TokenKind, ASTNode<T>> {\r\n  return apply(p, (data, [start, end]) => ({\r\n    data: data.data,\r\n    comments: [...data.comments],\r\n    range: { start: start?.pos.index!, end: end?.pos.index! },\r\n    _isNode: true,\r\n  }));\r\n}\r\n\r\nexport function commentify<T, U>(\r\n  p: Parser<TokenKind, T>,\r\n  convertToData: (t: T) => U,\r\n  convertToComments: (t: T) => Comment[][]\r\n): Parser<TokenKind, Commented<U>> {\r\n  return apply(comment_before(p), ([comments, data]) => ({\r\n    data: convertToData(data),\r\n    comments: [comments, ...convertToComments(data)],\r\n  }));\r\n}\r\n\r\nexport function commentify_no_comments_before<T, U>(\r\n  p: Parser<TokenKind, T>,\r\n  convertToData: (t: T) => U,\r\n  convertToComments: (t: T) => Comment[][]\r\n): Parser<TokenKind, Commented<U>> {\r\n  return apply(p, (data) => ({\r\n    data: convertToData(data),\r\n    comments: [...convertToComments(data)],\r\n  }));\r\n}\r\n\r\nexport function append_comments<T, U>(\r\n  p: Parser<TokenKind, T>,\r\n  convertToData: (t: T) => Commented<U>,\r\n  convertToComments: (t: T) => Comment[][]\r\n): Parser<TokenKind, Commented<U>> {\r\n  return apply(comment_before(p), ([comments, data]) => {\r\n    const underlyingNode = convertToData(data);\r\n    return {\r\n      data: underlyingNode.data,\r\n      comments: [\r\n        comments,\r\n        ...underlyingNode.comments,\r\n        ...convertToComments(data),\r\n      ],\r\n    };\r\n  });\r\n}\r\n\r\nexport function add_comments_and_transform<T, U, V>(\r\n  p: Parser<TokenKind, T>,\r\n  convertToOldCommented: (t: T) => Commented<U>,\r\n  convertToData: (u: U, t: T) => V,\r\n  mergeComments: (oldComments: Comment[][], t: T) => Comment[][]\r\n): Parser<TokenKind, Commented<V>> {\r\n  return apply(comment_before(p), ([comments, data]) => {\r\n    const oldCommented = convertToOldCommented(data);\r\n    return {\r\n      data: convertToData(oldCommented.data, data),\r\n      comments: [comments, ...mergeComments(oldCommented.comments, data)],\r\n    };\r\n  });\r\n}\r\n\r\n// okay in hindsight this really shouldn't be necessary\r\n// i shouldn't have to stretch any nodes\r\nexport function stretch_node<T, U>(\r\n  p: Parser<TokenKind, T>,\r\n  node: (t: T) => ASTNode<U>,\r\n  commentsBefore: (t: T) => Comment[][],\r\n  commentsAfter: (t: T) => Comment[][]\r\n): Parser<TokenKind, ASTNode<U>> {\r\n  return apply(comment_before(p), ([comments, data], [start, end]) => ({\r\n    ...node(data),\r\n    comments: [\r\n      comments,\r\n      ...commentsBefore(data),\r\n      ...node(data).comments,\r\n      ...commentsAfter(data),\r\n    ],\r\n    range: { start: start?.pos.index!, end: end?.pos.index! },\r\n  }));\r\n}\r\n\r\nexport function custom_node<T, U>(\r\n  p: Parser<TokenKind, T>,\r\n  node: (t: T) => U,\r\n  comments: (t: T) => Comment[][]\r\n): Parser<TokenKind, ASTNode<U>> {\r\n  return apply(p, (data, [start, end]) => ({\r\n    data: node(data),\r\n    comments: comments(data),\r\n    range: { start: start?.pos.index!, end: end?.pos.index! },\r\n    _isNode: true,\r\n  }));\r\n}\r\n\r\nexport function add_comments<T, U>(\r\n  p: Parser<TokenKind, T>,\r\n  node: (t: T) => ASTNode<U>,\r\n  comments: (t: T, oldComments: Comment[][]) => Comment[][]\r\n): Parser<TokenKind, ASTNode<U>> {\r\n  return apply(p, (data, [start, end]) => {\r\n    const astnode = node(data);\r\n    const newcomments = comments(data, astnode.comments);\r\n    return {\r\n      ...astnode,\r\n      comments: newcomments,\r\n    };\r\n  });\r\n}\r\n\r\nexport function binop_generic<T, U>(\r\n  left: Parser<TokenKind, ASTNode<T>>,\r\n  right: Parser<TokenKind, U>,\r\n  combine: (\r\n    l: ASTNode<T>,\r\n    r: U,\r\n    start: number,\r\n    end: number\r\n  ) => [T, Comment[][]],\r\n  no_sc?: boolean\r\n): Parser<TokenKind, ASTNode<T>> {\r\n  const combine_and_nodeify = (\r\n    l: ASTNode<T>,\r\n    r: U,\r\n    start: number,\r\n    end: number\r\n  ): ASTNode<T> => {\r\n    const [data, comments] = combine(l, r, start, end);\r\n    return {\r\n      data,\r\n      comments,\r\n      range: { start, end },\r\n      _isNode: true,\r\n    };\r\n  };\r\n\r\n  return (\r\n    // combined lrec case\r\n    (no_sc ? lrec : lrec_sc)(\r\n      apply(seq(left, right), ([l, r], [s, e]) =>\r\n        combine_and_nodeify(l, r, s?.pos.index!, e?.pos.index!)\r\n      ),\r\n      apply(right, (data, [start, end]) => ({ data, start, end })),\r\n      (l: ASTNode<T>, r) =>\r\n        combine_and_nodeify(l, r.data, l.range.start, r.end?.pos.index!)\r\n    )\r\n  );\r\n}\r\n\r\nexport function binop<NodeType extends ASTNode<T>, T>(\r\n  higher_prec: Parser<TokenKind, NodeType>,\r\n  self_prec: Parser<TokenKind, ASTNode<T>>,\r\n  ops: Parser<TokenKind, BinaryOpExpr[\"op\"]>\r\n): Parser<TokenKind, ASTNode<BinaryOpExpr> | NodeType> {\r\n  return lrec_sc(\r\n    higher_prec,\r\n    seq(comment_parser, ops, higher_prec),\r\n    (left, right) => {\r\n      const binopNode = {\r\n        type: \"binary-op\",\r\n        op: right[1],\r\n        left,\r\n        right: right[2],\r\n        _isExpr: true,\r\n      } as BinaryOpExpr;\r\n      return {\r\n        data: binopNode,\r\n        comments: [right[0]],\r\n        range: { start: left.range.start, end: right[2].range.end },\r\n        _isNode: true,\r\n      };\r\n    }\r\n  );\r\n}\r\n", "import { apply, Parser, str } from \"typescript-parsec\";\r\nimport { TokenKind } from \"./lexer\";\r\n\r\nexport function lstr<T extends string>(s: T): Parser<TokenKind, T> {\r\n  return apply(str(s), (s) => s.text as T);\r\n}\r\n", "import { FilesystemAdaptor } from \"../../filesystem/FilesystemAdaptor\";\r\nimport { BufferFormat } from \"../../pipeline-assembler/pipeline-format\";\r\n\r\nexport type GLPrimitive = {\r\n  count: 1 | 2 | 3 | 4;\r\n  type: \"float\" | \"int\" | \"uint\";\r\n};\r\n\r\nexport type UniformType =\r\n  | GLPrimitive\r\n  | {\r\n      type: \"sampler\";\r\n      dimensionality: \"2D\" | \"3D\" | \"2DArray\" | \"Cube\";\r\n      samplerType: \"float\" | \"int\" | \"uint\";\r\n    }\r\n  | {\r\n      type: \"sampler\";\r\n      samplerType: \"shadow\";\r\n      dimensionality: \"2D\" | \"2DArray\" | \"Cube\";\r\n    };\r\n\r\nexport type GLPrimitiveToNumber<G extends GLPrimitive> = G[\"count\"] extends 1\r\n  ? number\r\n  : G[\"count\"] extends 2\r\n    ? [number, number]\r\n    : G[\"count\"] extends 3\r\n      ? [number, number, number]\r\n      : [number, number, number, number];\r\n\r\nexport type UniformTypeValue<G extends UniformType> = G extends GLPrimitive\r\n  ? GLPrimitiveToNumber<G>\r\n  : TextureRef;\r\n\r\nfunction glp(count: 1 | 2 | 3 | 4, type: \"float\" | \"int\" | \"uint\") {\r\n  return { count, type };\r\n}\r\n\r\nexport function typeNameToGLPrimitive(\r\n  typename: string\r\n): GLPrimitive | undefined {\r\n  return {\r\n    float: glp(1, \"float\"),\r\n    vec2: glp(2, \"float\"),\r\n    vec3: glp(3, \"float\"),\r\n    vec4: glp(4, \"float\"),\r\n    int: glp(1, \"int\"),\r\n    ivec2: glp(2, \"int\"),\r\n    ivec3: glp(3, \"int\"),\r\n    ivec4: glp(4, \"int\"),\r\n    uint: glp(1, \"uint\"),\r\n    uvec2: glp(2, \"uint\"),\r\n    uvec3: glp(3, \"uint\"),\r\n    uvec4: glp(4, \"uint\"),\r\n  }[typename];\r\n}\r\n\r\nexport type ShaderSource = {\r\n  inputs: Record<string, GLPrimitive>;\r\n  outputs: Record<string, GLPrimitive>;\r\n  uniforms: Record<string, UniformType>;\r\n  shaderType: \"vertex\" | \"fragment\";\r\n  text: string;\r\n};\r\n\r\nexport type ShaderRef<Type extends \"vertex\" | \"fragment\"> = {\r\n  inputs: Record<string, GLPrimitive>;\r\n  outputs: Record<string, GLPrimitive>;\r\n  uniforms: Record<string, UniformType>;\r\n  shaderType: Type;\r\n  id: string;\r\n};\r\n\r\nexport type ProgramRef = {\r\n  inputs: Record<string, GLPrimitive>;\r\n  outputs: Record<string, GLPrimitive>;\r\n  uniforms: Record<string, UniformType>;\r\n  id: string;\r\n};\r\n\r\nexport type TextureDimension = {\r\n  type: \"dynamic\";\r\n  pixels: number;\r\n};\r\n\r\nexport type TextureRef = {\r\n  id: string;\r\n  width: TextureDimension;\r\n  height: TextureDimension;\r\n  dimensionality: \"2D\" | \"3D\" | \"2DArray\" | \"Cube\";\r\n  format: \"float\" | \"int\" | \"uint\";\r\n};\r\n\r\nexport type GLMessageContents =\r\n  | {\r\n      type: \"clear\";\r\n      color?: [number, number, number, number];\r\n      depth?: number;\r\n      stencil?: number;\r\n    }\r\n  | {\r\n      type: \"create-buffer\";\r\n      id: string;\r\n      source: {\r\n        type: \"array\";\r\n        spec: InterleavedBufferSpec;\r\n      };\r\n    }\r\n  | {\r\n      type: \"create-shader\";\r\n      source: ShaderSource;\r\n      id: string;\r\n    }\r\n  | {\r\n      type: \"create-program\";\r\n      vertex: ShaderRef<\"vertex\">;\r\n      fragment: ShaderRef<\"fragment\">;\r\n      id: string;\r\n    }\r\n  | {\r\n      type: \"draw\";\r\n      program: ProgramRef;\r\n      inputs: Record<string, BufferInputRef>;\r\n      outputs: Record<string, TextureRef | null>;\r\n      uniforms: Record<string, number | number[] | TextureRef>;\r\n      count: number;\r\n    }\r\n  | {\r\n      type: \"load-file\";\r\n      path: string;\r\n    }\r\n  | {\r\n      type: \"create-texture\";\r\n      pixels?: ArrayBuffer;\r\n      width: number;\r\n      height: number;\r\n      depth?: number;\r\n      internalformat: GLenum;\r\n      minFilter: GLenum;\r\n      magFilter: GLenum;\r\n      wrapS: GLenum;\r\n      wrapT: GLenum;\r\n      id: string;\r\n    };\r\n\r\nexport type GLMessageContentsType<T extends GLMessageContents[\"type\"]> =\r\n  GLMessageContents & { type: T };\r\n\r\nexport type GLMessageType<T extends GLMessageContents[\"type\"]> = {\r\n  id: string;\r\n  contents: GLMessageContentsType<T>;\r\n};\r\n\r\nexport type GLMessage = {\r\n  contents: GLMessageContents;\r\n  id: string;\r\n};\r\n\r\nexport type GLMessageResponseContents<Msg extends GLMessage> =\r\n  Msg extends GLMessageType<\"create-buffer\">\r\n    ? { spec: Msg[\"contents\"][\"source\"][\"spec\"]; id: string }\r\n    : Msg extends GLMessageType<\"create-shader\">\r\n      ? {\r\n          inputs: Msg[\"contents\"][\"source\"][\"inputs\"];\r\n          outputs: Msg[\"contents\"][\"source\"][\"outputs\"];\r\n          uniforms: Msg[\"contents\"][\"source\"][\"uniforms\"];\r\n          shaderType: Msg[\"contents\"][\"source\"][\"shaderType\"];\r\n          id: Msg[\"contents\"][\"id\"];\r\n        }\r\n      : Msg extends GLMessageType<\"create-program\">\r\n        ? {\r\n            inputs: Msg[\"contents\"][\"vertex\"][\"inputs\"];\r\n            outputs: Msg[\"contents\"][\"fragment\"][\"outputs\"];\r\n            uniforms: Msg[\"contents\"][\"vertex\"][\"uniforms\"] &\r\n              Msg[\"contents\"][\"fragment\"][\"uniforms\"];\r\n            id: Msg[\"contents\"][\"id\"];\r\n          }\r\n        : Msg extends GLMessageType<\"load-file\">\r\n          ? {\r\n              file: Blob | undefined;\r\n            }\r\n          : Msg extends GLMessageType<\"create-texture\">\r\n            ? TextureRef\r\n            : undefined;\r\n\r\nexport type GLMessageResponse<Msg extends GLMessage> = {\r\n  id: string;\r\n  content: GLMessageResponseContents<Msg>;\r\n};\r\n\r\nexport type GLMessageContext = {\r\n  gl: WebGL2RenderingContext;\r\n  buffers: Map<string, WebGLBuffer>;\r\n  shaders: Map<string, WebGLShader>;\r\n  programs: Map<string, WebGLProgram>;\r\n  textures: Map<string, WebGLTexture>;\r\n  fs: FilesystemAdaptor;\r\n  canvas: HTMLCanvasElement;\r\n};\r\n\r\nexport type InterleavedBufferSpec = {\r\n  count: 1 | 2 | 3 | 4;\r\n  size: 8 | 16 | 32;\r\n  encoding: \"int\" | \"normalized-int\" | \"float\" | \"uint\" | \"normalized-uint\";\r\n  value: number[];\r\n  name: string;\r\n  stride: number;\r\n  offset: number;\r\n}[];\r\n\r\nexport type BufferRef = {\r\n  spec: InterleavedBufferSpec;\r\n  id: string;\r\n};\r\n\r\nexport type BufferInputRef = {\r\n  buffer: BufferRef;\r\n  inputName: string;\r\n};\r\n\r\nfunction createInterleavedBuffer(\r\n  gl: WebGL2RenderingContext,\r\n  format: InterleavedBufferSpec\r\n) {\r\n  const buf = gl.createBuffer();\r\n  gl.bindBuffer(gl.ARRAY_BUFFER, buf);\r\n  const maxlen = format.reduce(\r\n    (prev, curr) => Math.max(prev, Math.ceil(curr.value.length / curr.count)),\r\n    0\r\n  );\r\n  const stride = format.reduce(\r\n    (prev, curr) => prev + (curr.count * curr.size) / 8,\r\n    0\r\n  );\r\n  const offsets = format.reduce(\r\n    (prev, curr) => prev.concat([prev.at(-1)! + (curr.count * curr.size) / 8]),\r\n    [0] as number[]\r\n  );\r\n  const bufferData = new ArrayBuffer(maxlen * stride);\r\n  const view = new DataView(bufferData);\r\n  for (let i = 0; i < maxlen; i++) {\r\n    const baseIndex = stride * i;\r\n    for (let j = 0; j < format.length; j++) {\r\n      const offset = offsets[j];\r\n      const formatItem = format[j];\r\n\r\n      for (let k = 0; k < formatItem.count; k++) {\r\n        const byteOffset = baseIndex + offset + (k * formatItem.size) / 8;\r\n        const arrayIndex = i * formatItem.count + k;\r\n        const arrayItem = formatItem.value.at(arrayIndex) ?? 0;\r\n\r\n        if (formatItem.encoding === \"float\") {\r\n          if (formatItem.size === 32) {\r\n            view.setFloat32(byteOffset, arrayItem, true);\r\n          } else if (formatItem.size === 16) {\r\n            view.setFloat16(byteOffset, arrayItem, true);\r\n          }\r\n        } else if (\r\n          formatItem.encoding === \"int\" ||\r\n          formatItem.encoding === \"normalized-int\"\r\n        ) {\r\n          if (formatItem.size === 32) {\r\n            view.setInt32(byteOffset, arrayItem, true);\r\n          } else if (formatItem.size === 16) {\r\n            view.setInt16(byteOffset, arrayItem, true);\r\n          } else {\r\n            view.setInt8(byteOffset, arrayItem);\r\n          }\r\n        } else {\r\n          if (formatItem.size === 32) {\r\n            view.setUint32(byteOffset, arrayItem, true);\r\n          } else if (formatItem.size === 16) {\r\n            view.setUint16(byteOffset, arrayItem, true);\r\n          } else {\r\n            view.setUint8(byteOffset, arrayItem);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  gl.bufferData(gl.ARRAY_BUFFER, bufferData, gl.STATIC_DRAW);\r\n  return buf;\r\n}\r\n\r\nfunction getVertexArrayType(\r\n  gl: WebGL2RenderingContext,\r\n  size: 8 | 16 | 32,\r\n  encoding: \"float\" | \"int\" | \"uint\" | \"normalized-int\" | \"normalized-uint\"\r\n) {\r\n  return {\r\n    8: {\r\n      float: gl.BYTE,\r\n      int: gl.BYTE,\r\n      \"normalized-int\": gl.BYTE,\r\n      uint: gl.UNSIGNED_BYTE,\r\n      \"normalized-uint\": gl.UNSIGNED_BYTE,\r\n    },\r\n\r\n    16: {\r\n      float: gl.HALF_FLOAT,\r\n      int: gl.SHORT,\r\n      \"normalized-int\": gl.SHORT,\r\n      uint: gl.UNSIGNED_SHORT,\r\n      \"normalized-uint\": gl.UNSIGNED_SHORT,\r\n    },\r\n    32: {\r\n      float: gl.FLOAT,\r\n      int: gl.INT,\r\n      \"normalized-int\": gl.INT,\r\n      uint: gl.UNSIGNED_INT,\r\n      \"normalized-uint\": gl.UNSIGNED_INT,\r\n    },\r\n  }[size][encoding];\r\n}\r\n\r\nexport async function executeGLMessage<Msg extends GLMessage>(\r\n  msgwrapper: Msg,\r\n  context: GLMessageContext\r\n): Promise<GLMessageResponse<Msg>> {\r\n  // @ts-expect-error\r\n  if (!msgwrapper.contents) return;\r\n  const msg = msgwrapper.contents;\r\n  const { gl } = context;\r\n  if (msg.type === \"clear\") {\r\n    const bitfield =\r\n      (msg.color ? gl.COLOR_BUFFER_BIT : 0) |\r\n      (msg.depth ? gl.DEPTH_BUFFER_BIT : 0) |\r\n      (msg.stencil ? gl.STENCIL_BUFFER_BIT : 0);\r\n    if (msg.color) gl.clearColor(...msg.color);\r\n    if (msg.depth) gl.clearDepth(msg.depth);\r\n    if (msg.stencil) gl.clearStencil(msg.stencil);\r\n    gl.clear(bitfield);\r\n    // @ts-expect-error\r\n    return {\r\n      id: msgwrapper.id,\r\n    };\r\n  } else if (msg.type === \"create-buffer\") {\r\n    if (msg.source.type === \"array\") {\r\n      const buf = createInterleavedBuffer(gl, msg.source.spec);\r\n      context.buffers.set(msg.id, buf);\r\n    }\r\n    return {\r\n      // @ts-expect-error\r\n      content: { spec: msg.source.spec, id: msg.id },\r\n      id: msgwrapper.id,\r\n    };\r\n  } else if (msg.type === \"create-shader\") {\r\n    const shader = gl.createShader(\r\n      msg.source.shaderType === \"vertex\" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER\r\n    )!;\r\n    gl.shaderSource(shader, msg.source.text);\r\n    gl.compileShader(shader);\r\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n      console.error(gl.getShaderInfoLog(shader));\r\n    }\r\n    context.shaders.set(msg.id, shader);\r\n    return {\r\n      // @ts-expect-error\r\n      content: {\r\n        inputs: msg.source.inputs,\r\n        outputs: msg.source.outputs,\r\n        uniforms: msg.source.uniforms,\r\n        shaderType: msg.source.shaderType,\r\n        id: msg.id,\r\n      },\r\n      id: msgwrapper.id,\r\n    };\r\n  } else if (msg.type === \"create-program\") {\r\n    const program = gl.createProgram();\r\n    gl.attachShader(program, context.shaders.get(msg.vertex.id)!);\r\n    gl.attachShader(program, context.shaders.get(msg.fragment.id)!);\r\n    gl.linkProgram(program);\r\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n      console.error(gl.getProgramInfoLog(program));\r\n    }\r\n    context.programs.set(msg.id, program);\r\n    return {\r\n      // @ts-expect-error\r\n      content: {\r\n        inputs: msg.vertex.inputs,\r\n        outputs: msg.fragment.outputs,\r\n        uniforms: {\r\n          ...msg.vertex.uniforms,\r\n          ...msg.fragment.uniforms,\r\n        },\r\n        id: msg.id,\r\n      },\r\n      id: msgwrapper.id,\r\n    };\r\n  } else if (msg.type === \"draw\") {\r\n    const program = context.programs.get(msg.program.id)!;\r\n    gl.useProgram(program);\r\n\r\n    for (const [name, type] of Object.entries(msg.program.inputs)) {\r\n      const bufferRef = msg.inputs[name];\r\n      const buf = context.buffers.get(bufferRef.buffer.id)!;\r\n      const input = bufferRef.buffer.spec.find(\r\n        (s) => bufferRef.inputName === s.name\r\n      )!;\r\n      gl.bindBuffer(gl.ARRAY_BUFFER, buf);\r\n      const location = gl.getAttribLocation(program, name);\r\n      gl.enableVertexAttribArray(location);\r\n      if (\r\n        input.encoding === \"float\" ||\r\n        input.encoding === \"normalized-int\" ||\r\n        input.encoding === \"normalized-uint\"\r\n      ) {\r\n        gl.vertexAttribPointer(\r\n          location,\r\n          input.count,\r\n          getVertexArrayType(gl, input.size, input.encoding),\r\n          input.encoding.startsWith(\"normalized\"),\r\n          input.stride,\r\n          input.offset\r\n        );\r\n      } else if (input.encoding === \"int\" || input.encoding === \"uint\") {\r\n        gl.vertexAttribIPointer(\r\n          location,\r\n          input.count,\r\n          getVertexArrayType(gl, input.size, input.encoding),\r\n          input.stride,\r\n          input.offset\r\n        );\r\n      }\r\n    }\r\n\r\n    if (\r\n      Object.entries(msg.program.outputs).length > 1 ||\r\n      msg.outputs[Object.keys(msg.program.outputs)?.[0]!]\r\n    ) {\r\n      console.log(\"USING FRAMEBUFFER\", msg);\r\n      const fbo = gl.createFramebuffer();\r\n      gl.bindFramebuffer(gl.FRAMEBUFFER, fbo);\r\n\r\n      const outputs = Object.entries(msg.program.outputs);\r\n\r\n      for (const [name, type] of outputs) {\r\n        const textureRef = msg.outputs[name];\r\n        if (textureRef === null) continue;\r\n        gl.viewport(0, 0, textureRef.width.pixels, textureRef.height.pixels);\r\n        const location = gl.getFragDataLocation(program, name);\r\n        const tex = context.textures.get(textureRef.id)!;\r\n        gl.bindTexture(gl.TEXTURE_2D, tex);\r\n        gl.framebufferTexture2D(\r\n          gl.FRAMEBUFFER,\r\n          gl.COLOR_ATTACHMENT0 + location,\r\n          gl.TEXTURE_2D,\r\n          tex,\r\n          0\r\n        );\r\n      }\r\n\r\n      gl.drawBuffers(outputs.map((e, i) => gl.COLOR_ATTACHMENT0 + i));\r\n    } else {\r\n      gl.viewport(0, 0, context.canvas.width, context.canvas.height);\r\n      gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n    }\r\n\r\n    const textureBindings = new Map<WebGLTexture, number>();\r\n    let bindingIndex = 0;\r\n\r\n    for (const [name, type] of Object.entries(msg.program.uniforms)) {\r\n      if (type.type !== \"sampler\") continue;\r\n      let uniformData = msg.uniforms[name] as TextureRef;\r\n      const tex = context.textures.get(uniformData.id)!;\r\n      let binding = textureBindings.get(tex);\r\n      if (!binding) {\r\n        gl.activeTexture(gl.TEXTURE0 + bindingIndex);\r\n        // TODO: support other types of textures\r\n        gl.bindTexture(gl.TEXTURE_2D, tex);\r\n        textureBindings.set(tex, bindingIndex);\r\n        binding = bindingIndex;\r\n        bindingIndex++;\r\n      }\r\n\r\n      const loc = gl.getUniformLocation(program, name);\r\n      gl.uniform1i(loc, binding);\r\n    }\r\n\r\n    for (const [name, type] of Object.entries(msg.program.uniforms)) {\r\n      if (type.type === \"sampler\") continue;\r\n      let uniformData = msg.uniforms[name];\r\n      if (!Array.isArray(uniformData)) uniformData = [uniformData as number];\r\n      const loc = gl.getUniformLocation(program, name);\r\n\r\n      console.log(name, type, uniformData);\r\n\r\n      let uniformFunc: keyof typeof gl = (\r\n        {\r\n          float: {\r\n            1: \"uniform1f\",\r\n            2: \"uniform2f\",\r\n            3: \"uniform3f\",\r\n            4: \"uniform4f\",\r\n          },\r\n          int: {\r\n            1: \"uniform1i\",\r\n            2: \"uniform2i\",\r\n            3: \"uniform3i\",\r\n            4: \"uniform4i\",\r\n          },\r\n          uint: {\r\n            1: \"uniform1ui\",\r\n            2: \"uniform2i\",\r\n            3: \"uniform3ui\",\r\n            4: \"uniform4ui\",\r\n          },\r\n        } as const\r\n      )[type.type][type.count];\r\n\r\n      // @ts-expect-error\r\n      gl[uniformFunc](loc, ...uniformData);\r\n    }\r\n\r\n    gl.drawArrays(gl.TRIANGLES, 0, msg.count);\r\n    // @ts-expect-error\r\n    return {\r\n      id: msgwrapper.id,\r\n    };\r\n  } else if (msg.type === \"load-file\") {\r\n    const file = await context.fs.readFile(msg.path);\r\n    return {\r\n      id: msgwrapper.id,\r\n      // @ts-expect-error\r\n      content: {\r\n        file,\r\n      },\r\n    };\r\n  } else if (msg.type === \"create-texture\") {\r\n    const tex = gl.createTexture();\r\n    gl.bindTexture(gl.TEXTURE_2D, tex);\r\n    gl.texImage2D(\r\n      gl.TEXTURE_2D,\r\n      0,\r\n      msg.internalformat,\r\n      msg.width,\r\n      msg.height,\r\n      0,\r\n      gl.RGBA,\r\n      gl.UNSIGNED_BYTE,\r\n      msg.pixels ? new Uint8Array(msg.pixels) : null\r\n    );\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, msg.minFilter);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, msg.magFilter);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, msg.wrapS);\r\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, msg.wrapT);\r\n    context.textures.set(msg.id, tex);\r\n    return {\r\n      id: msgwrapper.id,\r\n      // @ts-expect-error\r\n      content: {\r\n        id: msg.id,\r\n        width: { pixels: msg.width },\r\n        height: { pixels: msg.height },\r\n        dimensionality: \"2D\",\r\n        format: \"float\",\r\n      },\r\n    };\r\n  }\r\n\r\n  // @ts-expect-error\r\n  return;\r\n}\r\n", "import {\r\n  GLPrimitive,\r\n  typeNameToGLPrimitive,\r\n  UniformType,\r\n} from \"../components/iframe-runtime/GLMessageProtocol\";\r\nimport { TranslationUnit } from \"./parser\";\r\n\r\nexport function getInputsOutputsAndUniforms(tu: TranslationUnit) {\r\n  const uniforms: Record<string, UniformType> = {};\r\n  const inputs: Record<string, GLPrimitive> = {};\r\n  const outputs: Record<string, GLPrimitive> = {};\r\n\r\n  for (const ed of tu.data) {\r\n    if (ed.data.type === \"declaration\") {\r\n      const decl = ed.data.decl.data;\r\n      if (decl.type === \"declarator-list\") {\r\n        const init = decl.declaratorList.data.init.data;\r\n        if (init.type === \"type\") {\r\n          const qualifier = init.declType.data.qualifier?.data;\r\n          const specifier =\r\n            init.declType.data.specifier.data.specifier.data.typeName.data;\r\n          let typeDesc: UniformType | undefined;\r\n          if (specifier.type === \"builtin\") {\r\n            const typename = specifier.name.data;\r\n            typeDesc = typeNameToGLPrimitive(typename);\r\n            if (!typeDesc) {\r\n              typeDesc = {\r\n                type: \"sampler\",\r\n                dimensionality: \"2D\",\r\n                samplerType: \"float\",\r\n              };\r\n            }\r\n          }\r\n          if (qualifier && typeDesc) {\r\n            const isUniform = qualifier.storageQualifier?.data === \"uniform\";\r\n            const isIn = qualifier.storageQualifier?.data?.endsWith(\"in\");\r\n            const isOut = qualifier.storageQualifier?.data?.endsWith(\"out\");\r\n\r\n            for (const item of decl.declaratorList.data.declarations.data) {\r\n              const name = item.data.name.data;\r\n              if (isUniform) {\r\n                uniforms[name] = typeDesc;\r\n              } else if (isIn && typeDesc.type !== \"sampler\") {\r\n                inputs[name] = typeDesc;\r\n              } else if (isOut && typeDesc.type !== \"sampler\") {\r\n                outputs[name] = typeDesc;\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return { uniforms, inputs, outputs };\r\n}\r\n", "import { v4 } from \"uuid\";\r\nimport {\r\n  GLMessage,\r\n  GLMessageResponse,\r\n  BufferRef,\r\n  GLPrimitive,\r\n  ShaderRef,\r\n  typeNameToGLPrimitive,\r\n  ProgramRef,\r\n  BufferInputRef,\r\n  GLPrimitiveToNumber,\r\n  UniformTypeValue,\r\n  TextureRef,\r\n} from \"./GLMessageProtocol\";\r\nimport { parseGLSLWithoutPreprocessing } from \"../../glsl-analyzer/parser-combined\";\r\nimport { getInputsOutputsAndUniforms } from \"../../glsl-analyzer/get-inputs-outputs\";\r\n\r\nexport function createGLMessageClient(\r\n  send: <Msg extends GLMessage>(msg: Msg) => Promise<GLMessageResponse<Msg>>\r\n) {\r\n  return {\r\n    clear(\r\n      color?: [number, number, number, number],\r\n      depth?: number,\r\n      stencil?: number\r\n    ) {\r\n      return send({\r\n        contents: {\r\n          type: \"clear\",\r\n          color,\r\n          depth,\r\n          stencil,\r\n        },\r\n        id: v4(),\r\n      });\r\n    },\r\n    async createBufferFromArray<\r\n      P extends {\r\n        array: number[];\r\n        count: 1 | 2 | 3 | 4;\r\n        encoding:\r\n          | \"float\"\r\n          | \"int\"\r\n          | \"uint\"\r\n          | \"normalized-int\"\r\n          | \"normalized-uint\";\r\n        size: 8 | 16 | 32;\r\n      },\r\n    >(params: P) {\r\n      const { count, encoding, size, array } = params;\r\n      return (\r\n        await send({\r\n          id: v4(),\r\n          contents: {\r\n            type: \"create-buffer\",\r\n            id: v4(),\r\n            source: {\r\n              type: \"array\",\r\n              spec: [\r\n                {\r\n                  count,\r\n                  encoding,\r\n                  size,\r\n                  value: array,\r\n                  name: \"attr\",\r\n                  stride: 0,\r\n                  offset: 0,\r\n                },\r\n              ],\r\n            },\r\n          },\r\n        })\r\n      ).content;\r\n    },\r\n    async linkProgram<VertexOutsFragIns extends Record<string, GLPrimitive>>(\r\n      vertex: ShaderRef<\"vertex\"> & { outputs: VertexOutsFragIns },\r\n      fragment: ShaderRef<\"fragment\"> & { inputs: VertexOutsFragIns }\r\n    ) {\r\n      return (\r\n        await send({\r\n          id: v4(),\r\n          contents: {\r\n            type: \"create-program\",\r\n            id: v4(),\r\n            vertex,\r\n            fragment,\r\n          },\r\n        })\r\n      ).content;\r\n    },\r\n    sendGLMessage<Msg extends GLMessage>(msg: Msg) {\r\n      return send(msg);\r\n    },\r\n    async draw<Prog extends ProgramRef>(\r\n      program: Prog,\r\n      count: number,\r\n      inputs: { [Key in keyof Prog[\"inputs\"]]: BufferInputRef },\r\n      outputs: { [Key in keyof Prog[\"outputs\"]]: TextureRef | null },\r\n      uniforms: {\r\n        [Key in keyof Prog[\"uniforms\"]]: UniformTypeValue<\r\n          Prog[\"uniforms\"][Key]\r\n        >;\r\n      }\r\n    ) {\r\n      return send({\r\n        id: v4(),\r\n        contents: {\r\n          type: \"draw\",\r\n          program,\r\n          inputs,\r\n          outputs,\r\n          uniforms,\r\n          count,\r\n        },\r\n      });\r\n    },\r\n    async create8BitRGBATexture(\r\n      pixels: ArrayBuffer | undefined,\r\n      width: number,\r\n      height: number\r\n    ) {\r\n      return (\r\n        await send({\r\n          id: v4(),\r\n          contents: {\r\n            type: \"create-texture\",\r\n            pixels,\r\n            width,\r\n            height,\r\n            internalformat: WebGL2RenderingContext.RGBA8,\r\n            minFilter: WebGL2RenderingContext.LINEAR,\r\n            magFilter: WebGL2RenderingContext.LINEAR,\r\n            wrapS: WebGL2RenderingContext.REPEAT,\r\n            wrapT: WebGL2RenderingContext.REPEAT,\r\n            id: v4(),\r\n          },\r\n        })\r\n      ).content;\r\n    },\r\n    async loadShader(path: string, type: \"vertex\" | \"fragment\") {\r\n      const shaderFile = await send({\r\n        id: v4(),\r\n        contents: {\r\n          type: \"load-file\",\r\n          path,\r\n        },\r\n      });\r\n\r\n      if (!shaderFile.content.file) return;\r\n\r\n      const text = await shaderFile.content.file.text();\r\n\r\n      const textWithoutVersion = text.replace(/^.*\\#version 300 es/, \"\");\r\n\r\n      const parsed = parseGLSLWithoutPreprocessing(textWithoutVersion);\r\n\r\n      if (!parsed.data.success) return;\r\n\r\n      const tu = parsed.data.data.translationUnit;\r\n\r\n      const shader = await send({\r\n        id: v4(),\r\n        contents: {\r\n          type: \"create-shader\",\r\n          source: {\r\n            shaderType: type,\r\n            text,\r\n            ...getInputsOutputsAndUniforms(tu),\r\n          },\r\n          id: v4(),\r\n        },\r\n      });\r\n\r\n      return shader.content;\r\n    },\r\n  };\r\n}\r\n", "import { createGLMessageClient } from \"./GLMessageClient\";\r\n\r\nconst client = createGLMessageClient((msg) => {\r\n  return new Promise((resolve, reject) => {\r\n    window.addEventListener(\"message\", (e) => {\r\n      if (e.data?.id === msg.id) {\r\n        resolve(e.data);\r\n      }\r\n    });\r\n    window.parent.postMessage(msg, \"*\");\r\n  });\r\n});\r\n\r\nfor (const [k, v] of Object.entries(client)) {\r\n  // @ts-expect-error\r\n  window[k] = v;\r\n}\r\n"],
  "mappings": "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KAAK,KAAK,QAOR,KANE,IAAIF,EAAc,CACvB,QAAS,GACT,MAAOE,EAAE,KAAK,KAAK,KAAK,CAC1B,CAAC,CAIL,CACF,EAEO,SAASC,GAASF,EAAS,CAChC,OAAO,IAAIF,GAAa,CAAE,QAAS,GAAM,KAAAE,CAAK,CAAC,CACjD,CAEO,SAASG,GAAUC,EAAU,CAClC,OAAO,IAAIN,GAAa,CAAE,QAAS,GAAO,MAAAM,CAAM,CAAC,CACnD,CClDA,IAAAC,GAAgC,OCAzB,IAAMC,GAAgB,CAE3B,QACA,OACA,QACA,MACA,OACA,QACA,WACA,KACA,OACA,MACA,KACA,UACA,SACA,SACA,OACA,UACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,QACA,OACA,OACA,OACA,OACA,OACA,OACA,WACA,KACA,MACA,QACA,UACA,OACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,SACA,YACA,YACA,cACA,kBACA,oBACA,iBACA,uBACA,aACA,aACA,eACA,kBACA,aACA,aACA,eACA,kBACA,SACA,OACA,QACA,YACA,QACA,UACA,OACA,OACA,QAEA,SACA,SACA,SACA,YACA,cACF,EAEaC,GAAe,CAC1B,KACA,KACA,KACA,KACA,KACA,MACA,MACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,IACA,GACF,EDhHO,IAAMC,MAAQ,eAAW,CAE9B,CACE,GACA,IAAI,OAAOC,GAAc,IAAKC,GAAM,IAAIA,CAAC,EAAE,EAAE,KAAK,GAAG,EAAG,GAAG,EAC3D,CACF,EAEA,CACE,GACA,IAAI,OACF,KAAKC,GAAa,IAAKC,GACrBA,EACG,MAAM,EAAE,EACR,IAAKC,GAAM,KAAKA,CAAC,EAAE,EACnB,KAAK,EAAE,CACZ,EAAE,KAAK,GAAG,CAAC,IACX,GACF,EACA,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",
  "names": ["posToString", "pos", "TokenError", "_super", "__extends", "errorMessage", "_this", "exports", "TokenRangeError", "first", "next", "extractByPositionRange", "input", "firstIndex", "nextIndex", "extractByTokenRange", "TokenImpl", "lexer", "kind", "text", "keep", "LexerImpl", "rules", "_i", "_a", "rule", "indexStart", "rowBegin", "columnBegin", "subString", "result", "_b", "regexp", "rowEnd", "columnEnd", "_c", "text_1", "c", "newResult", "index", "token", "buildLexer", "betterError", "e1", "e2", "exports", "resultOrError", "result", "error", "successful", "unableToConsumeToken", "token", "ParserInterface_1", "nil", "token", "exports", "succ", "value", "fail", "errorMessage", "str", "toMatch", "tok", "ParserInterface_1", "combine", "first", "continuations", "_i", "token", "firstOutput", "result", "error", "continuations_1", "c", "steps", "_a", "steps_1", "step", "output", "_b", "_c", "candidate", "exports", "ParserInterface_1", "seq", "ps", "_i", "token", "error", "result", "ps_1", "p", "steps", "_a", "steps_1", "step", "output", "_b", "_c", "candidate", "exports", "ParserInterface_1", "alt", "ps", "_i", "token", "error", "result", "successful", "ps_1", "p", "output", "exports", "ParserInterface_1", "alt_sc", "ps", "_i", "token", "error", "ps_1", "output", "exports", "AlternativeParser_1", "TokenParser_1", "opt", "p", "exports", "opt_sc", "token", "output", "SequencialParser_1", "apply", "p", "callback", "token", "output", "value", "exports", "kleft", "p1", "p2", "kright", "kmid", "p3", "ApplyParser_1", "ParserInterface_1", "SequencialParser_1", "TokenParser_1", "rep", "p", "reprParser", "repr", "token", "output", "exports", "rep_sc", "error", "result", "steps", "_i", "steps_1", "step", "_a", "_b", "candidate", "i", "rep_n", "count", "candidates", "newCandidates", "candidates_1", "applyList", "first", "tail", "__spreadArrays", "list", "s", "list_sc", "list_n", "value", "applyLrec", "callback", "lrec", "q", "lrec_sc", "amb", "p", "token", "branches", "group", "_i", "_a", "r", "rs", "exports", "err", "p", "errorMessage", "token", "branches", "exports", "errd", "defaultValue", "Lexer_1", "ParserInterface_1", "RuleImpl", "parser", "token", "rule", "exports", "expectEOF", "output", "filtered", "error", "_i", "_a", "candidate", "expectSingleResult", "lazy", "thunk", "token", "exports", "defineReadOnly", "target", "propName", "value", "makeParserModule", "definitions", "parserModule", "key", "parserThunk", "_i", "_a", "_b", "__exportStar", "exports", "byteToHex", "i", "unsafeStringify", "arr", "offset", "getRandomValues", "rnds8", "rng", "randomUUID", "native_default", "v4", "options", "buf", "offset", "native_default", "rnds", "rng", "i", "unsafeStringify", "v4_default", "import_typescript_parsec", "Result", "_Result", "data", "f", "ok", "err", "error", "import_typescript_parsec", "GLSL_KEYWORDS", "GLSL_SYMBOLS", "lexer", "GLSL_KEYWORDS", "k", "GLSL_SYMBOLS", "s", "c", "import_typescript_parsec", "import_typescript_parsec", "comment_parser", "c", "comment_before", "p", "with_comment_before", "commentify", "s", "nodeify", "comments", "data", "start", "end", "nodeify_commented", "convertToData", "convertToComments", "commentify_no_comments_before", "append_comments", "underlyingNode", "add_comments_and_transform", "convertToOldCommented", "mergeComments", "oldCommented", "add_comments", "p", "node", "comments", "data", "start", "end", "astnode", "newcomments", "binop_generic", "left", "right", "combine", "no_sc", "combine_and_nodeify", "l", "r", "s", "e", "binop", "higher_prec", "self_prec", "ops", "comment_parser", "import_typescript_parsec", "lstr", "s", "glslParseInt", "str", "variable_identifier", "primary_expression", "postfix_expression", "integer_expression", "function_call", "function_call_or_method", "function_call_generic", "function_call_header_no_parameters", "function_call_header_with_parameters", "function_call_header", "function_identifier", "unary_expression", "unary_operator", "multiplicative_expression", "additive_expression", "shift_expression", "relational_expression", "equality_expression", "and_expression", "exclusive_or_expression", "inclusive_or_expression", "logical_and_expression", "logical_xor_expression", "logical_or_expression", "conditional_expression", "assignment_expression", "assignment_operator", "expression", "constant_expression", "declaration", "function_prototype", "function_declarator", "function_header_with_parameters", "function_header", "parameter_declarator", "parameter_declaration", "parameter_qualifier", "parameter_type_specifier", "init_declarator_list", "single_declaration", "fully_specified_type", "invariant_qualifier", "interpolation_qualifier", "layout_qualifier", "layout_qualifier_id_list", "layout_qualifier_id", "parameter_type_qualifier", "type_qualifier", "storage_qualifier", "type_specifier", "type_specifier_no_prec", "type_specifier_nonarray", "precision_qualifier", "struct_specifier", "struct_declaration_list", "struct_declaration", "struct_declarator_list", "struct_declarator", "initializer", "declaration_statement", "statement", "statement_no_new_scope", "statement_with_scope", "simple_statement", "compound_statement_with_scope", "compound_statement_no_new_scope", "statement_list", "expression_statement", "selection_statement", "selection_rest_statement", "condition", "switch_statement", "switch_statement_list", "case_label", "iteration_statement", "for_init_statement", "conditionopt", "for_rest_statement", "jump_statement", "translation_unit", "external_declaration", "function_definition", "placeholder", "nodeify", "s", "tok", "float", "bool", "add_comments", "comment_parser", "t", "c", "oc", "field_access", "binop_generic", "left", "right", "nodeify_commented", "append_comments", "add_comments_and_transform", "i", "o", "e", "with_comment_before", "expr", "binop", "lstr", "commentify", "l", "x", "v", "fh", "pd", "pts", "ptq", "pq", "dos", "identifier_declaration", "qualifier", "specifier", "d", "q", "lq", "sq", "iq", "invq", "intq", "precision", "decl", "stmt1", "rest", "commentify_no_comments_before", "import_option", "import_decl", "lexGLSL", "source", "tokens", "lexer", "ok", "parseGLSLWithoutPreprocessing", "source", "tokens", "lexGLSL", "err", "translationUnit", "translation_unit", "ok", "error", "glp", "count", "type", "typeNameToGLPrimitive", "typename", "getInputsOutputsAndUniforms", "tu", "uniforms", "inputs", "outputs", "ed", "decl", "init", "qualifier", "specifier", "typeDesc", "typename", "typeNameToGLPrimitive", "isUniform", "isIn", "isOut", "item", "name", "createGLMessageClient", "send", "color", "depth", "stencil", "v4_default", "params", "count", "encoding", "size", "array", "vertex", "fragment", "msg", "program", "inputs", "outputs", "uniforms", "pixels", "width", "height", "path", "type", "shaderFile", "text", "textWithoutVersion", "parsed", "parseGLSLWithoutPreprocessing", "tu", "getInputsOutputsAndUniforms", "client", "createGLMessageClient", "msg", "resolve", "reject", "e", "k", "v"]
}
